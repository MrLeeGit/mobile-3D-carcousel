var async = require("async");
var RawModule = require("webpack/lib/RawModule");
var path = require("path");

var gModuleVersion = {
    __thisProjectName: '',
    __stopBundle: false
};

function moduleDependency() {
    console.log("Webpack plugin moduleDependency Init");
}

function loaderToIdent(data) {
    if (!data.options)
        return data.loader;
    if (typeof data.options === "string")
        return data.loader + "?" + data.options;
    if (typeof data.options !== "object")
        throw new Error("loader options must be string or object");
    if (data.ident)
        return data.loader + "??" + data.ident;
    return data.loader + "?" + JSON.stringify(data.options);
}

function identToLoaderRequest(resultString) {
    var idx = resultString.indexOf("?");
    var options;

    if (idx >= 0) {
        options = resultString.substr(idx + 1);
        resultString = resultString.substr(0, idx);

        return {
            loader: resultString,
            options: options
        };
    } else {
        return {
            loader: resultString
        };
    }
}

function canBundle(entryCallStack) {
    var result = {
        result: true,
        msg: []
    };
    for (var entry in entryCallStack) {
        for (var lib in entryCallStack[entry]) {
            libVersionNum = Object.keys(entryCallStack[entry][lib]).length;
            if (libVersionNum > 1) {
                // 依赖库不止一个版本
                result.result = false;
                // result.msg.push('\nThere are ' + libVersionNum + ' version of ' + lib + ' in ' + entry + ' :');
                // for (version in entryCallStack[entry][lib]) {
                //     result.msg.push('Version: ' + version);
                //     result.msg = result.msg.concat(entryCallStack[entry][lib][version]);
                // }
            }
            result.msg.push('\nThere are ' + libVersionNum + ' version of ' + lib + ' in ' + entry + ' :');
            for (version in entryCallStack[entry][lib]) {
                result.msg.push('Version: ' + version);
                result.msg = result.msg.concat(entryCallStack[entry][lib][version]);
            }
        }
    }
    return result
}

function recursiveDependenceBuild(entry, prefix, callStack) {
    var prefix = prefix + '--> ';
    var deep = prefix.match(/-->/g).length;     // 递归深度 超过十层默认为循环引用

    var dependenceList = [];
    if (entry == null) {
        return dependenceList;
    }
    var dependencies = entry.dependencies;

    // 处理require.ensure加载进来的JS
    if (entry.blocks.length !== 0) {
        entry.blocks.forEach(function (block) {
            // 如果需要把分出来的js文件在依赖树中标注出来，就在这里添加属性（找到文件名之类的），在下面dependencies循环中再处理
            dependencies = dependencies.concat(block.dependencies);
        })
    }

    var requireList = ['HarmonyImportDependency', 'CommonJsRequireDependency', 'AMDRequireDependency', 'RequireEnsureItemDependency']
    dependencies.forEach(function (dependence) {
        if (dependence.module == null) {
            return;
        }
        var type = dependence.__proto__.constructor.name;
        if (requireList.indexOf(type) !== -1) {
            var temp = {};
            temp.name = dependence.request;
            temp.type = type === 'AMDRequireDependency' ? 'AMD' : 'CMD';
            if (gModuleVersion[temp.name]) {
                // 如果存在对应的依赖 比较路径 temp.name类似 @mfelibs/test-version-biz
                gModuleVersion[temp.name].forEach(function (subModule) {
                    if (subModule.path === dependence.module.userRequest) {
                        temp.version = subModule.version
                    }
                });
            } else {
                // 如果不存在对应的依赖 可能是用户自定义的js   temp.name是js文件的绝对或相对地址
                // 例如入口文件中 import './index2'  temp.name为 ./index2
                // 这种情况下取当前工程的版本当做此文件的版本
                gModuleVersion[gModuleVersion.__thisProjectName].forEach(function (subModule) {
                    if (subModule.path === dependence.module.userRequest) {
                        temp.version = subModule.version
                    }
                });
            }

            if (temp.version) {
                // 没有version 默认为引用的是该模块内置js文件或者公用模块，非第三方模块。  忽略掉，不在依赖树内显示
                // 直接忽略的另一个原因是 递归可能无法终止，因为引用的公共模块内又引了公共模块

                // callStack相关
                var tempPrefix = prefix + temp.name;
                callStack[temp.name] = callStack[temp.name] || {};
                if (callStack[temp.name][temp.version]) {
                    callStack[temp.name][temp.version].push(tempPrefix);
                } else {
                    callStack[temp.name][temp.version] = [tempPrefix];
                }

                if (deep > 11) {
                    gModuleVersion.__stopBundle = true;
                    var msg = '!!!Here may be a circular reference. Stop dependency graph build!!!';
                    temp.dependency = msg;
                    console.log(msg)
                    dependenceList.push(temp);
                    return;
                }

                temp.dependency = recursiveDependenceBuild(dependence.module, tempPrefix, callStack);

                // dependenceList相关                
                dependenceList.push(temp);
            }
        }
    })
    return dependenceList
}

function setGModuleVersion(requests) {
    requests.forEach(function (request) {
        if (request == null) {
            return;
        }
        if (request.path.indexOf('node_modules') === -1) {
            // 项目名称在compiler和compilation中皆获取不到 
            // 所以在依赖的文件中 根据js路径判断是否是用户自定义js 非引入的第三方js 
            // 若非第三方js即可判断为用户编写的js 从而可以在request中获取到项目名称
            gModuleVersion.__thisProjectName = request.descriptionFileData.name
        }
        if (!gModuleVersion[request.descriptionFileData.name]) {
            gModuleVersion[request.descriptionFileData.name] = [{
                'path': request.path,
                'version': request.descriptionFileData.version
            }]
        } else {
            var newVersion = false;
            gModuleVersion[request.descriptionFileData.name].forEach(function (subModule) {
                if (subModule.path !== request.path || subModule.version !== request.descriptionFileData.version) {
                    newVersion = true;
                }
            })
            if (newVersion) {
                gModuleVersion[request.descriptionFileData.name].push({
                    'path': request.path,
                    'version': request.descriptionFileData.version
                })
            }
        }
    })
}

moduleDependency.prototype.apply = function (compiler) {
    var requests = [];
    compiler.plugin("normal-module-factory", function (nmf) {
        // 重写NormalModuleFactory.js内120行 为了得到request内的模块版本信息
        nmf.plugin("resolver", function () {
            var _this = nmf;
            return function (data, callback) {
                var contextInfo = data.contextInfo;
                var context = data.context;
                var request = data.request;
                var resolveContextInfo = {};

                var noAutoLoaders = /^-?!/.test(request);
                var noPrePostAutoLoaders = /^!!/.test(request);
                var noPostAutoLoaders = /^-!/.test(request);
                var elements = request.replace(/^-?!+/, "").replace(/!!+/g, "!").split("!");
                var resource = elements.pop();
                elements = elements.map(identToLoaderRequest);

                async.parallel([
                    function (callback) {
                        _this.resolveRequestArray(resolveContextInfo, context, elements, _this.resolvers.loader, callback);
                    },
                    function (callback) {
                        if (resource === "" || resource[0] === "?")
                            return callback(null, resource);
                        _this.resolvers.normal.resolve(resolveContextInfo, context, resource, function (err, result, request) {
                            requests.push(request);
                            if (err) return callback(err);
                            callback(null, result);
                        });
                    }
                ], function (err, results) {
                    if (err) return callback(err);
                    var loaders = results[0];
                    resource = results[1];

                    // translate option idents
                    try {
                        loaders.forEach(function (item) {
                            if (typeof item.options === "string" && /^\?/.test(item.options)) {
                                item.options = _this.ruleSet.findOptionsByIdent(item.options.substr(1));
                            }
                        });
                    } catch (e) {
                        return callback(e);
                    }

                    if (resource === false)
                        return callback(null,
                            new RawModule("/* (ignored) */",
                                "ignored " + context + " " + request,
                                request + " (ignored)")); // ignored

                    var userRequest = loaders.map(loaderToIdent).concat([resource]).join("!");

                    var resourcePath = resource;
                    var resourceQuery = "";
                    var queryIndex = resourcePath.indexOf("?");
                    if (queryIndex >= 0) {
                        resourceQuery = resourcePath.substr(queryIndex);
                        resourcePath = resourcePath.substr(0, queryIndex);
                    }

                    var result = _this.ruleSet.exec({
                        resource: resourcePath,
                        resourceQuery: resourceQuery,
                        issuer: contextInfo.issuer
                    });
                    var settings = {};
                    var useLoadersPost = [];
                    var useLoaders = [];
                    var useLoadersPre = [];
                    result.forEach(function (r) {
                        if (r.type === "use") {
                            if (r.enforce === "post" && !noPostAutoLoaders && !noPrePostAutoLoaders)
                                useLoadersPost.push(r.value);
                            else if (r.enforce === "pre" && !noPrePostAutoLoaders)
                                useLoadersPre.push(r.value);
                            else if (!r.enforce && !noAutoLoaders && !noPrePostAutoLoaders)
                                useLoaders.push(r.value);
                        } else {
                            settings[r.type] = r.value;
                        }
                    });
                    async.parallel([
                        _this.resolveRequestArray.bind(_this, resolveContextInfo, _this.context, useLoadersPost, _this.resolvers.loader),
                        _this.resolveRequestArray.bind(_this, resolveContextInfo, _this.context, useLoaders, _this.resolvers.loader),
                        _this.resolveRequestArray.bind(_this, resolveContextInfo, _this.context, useLoadersPre, _this.resolvers.loader)
                    ], function (err, results) {
                        if (err) return callback(err);
                        loaders = results[0].concat(loaders).concat(results[1]).concat(results[2]);
                        process.nextTick(onDoneResolving);
                    });

                    function onDoneResolving() {
                        callback(null, {
                            context: context,
                            request: loaders.map(loaderToIdent).concat([resource]).join("!"),
                            dependencies: data.dependencies,
                            userRequest: userRequest,
                            rawRequest: request,
                            loaders: loaders,
                            resource: resource,
                            parser: _this.getParser(settings.parser)
                        });
                    }
                });
            };
        });
    });

    compiler.plugin("emit", function (compilation, callback) {
        setGModuleVersion(requests);

        var dependencyGraph = [];
        var entryCallStack = {};
        compilation.chunks.forEach(function (chunk) {
            var entry = {};
            if (chunk.entryModule != null) { // 拥有entry的模块
                entry.entry = chunk.name;   // 入口名
                entryCallStack[entry.entry] = {};
                entry.dependency = recursiveDependenceBuild(chunk.entryModule, entry.entry, entryCallStack[entry.entry]) // 依赖模块数组
                dependencyGraph.push(entry)
            }
        });

        var result = canBundle(entryCallStack);
        if (gModuleVersion.__stopBundle) {
            // 可能有循环引用 终止打包
            console.error('---Maybe Circular Reference---');
            result.msg.forEach(function (msg) {
                console.log(msg);
            })
            console.log('---End bundle! Please make sure your libs has no circular reference!---');
            console.log('---If you have any questions, please contact zihao5@staff.sina.com.cn---');
        }
        else if (result.result) {
            // 无版本冲突 生成依赖树文件 正常执行后续操作

            // dependencyGraphJsonStr = JSON.stringify(dependencyGraph)
            // compilation.assets['dependencyGraph.json'] = {
            //     'source': function () {
            //         return dependencyGraphJsonStr
            //     },
            //     'size': function () {
            //         return dependencyGraphJsonStr.length;
            //     }
            // };
            // console.log("Prepare to generate dependencyGraph.json in " + compilation.outputOptions.path);
            // callback();

            var dependencyGraphJsonStr = JSON.stringify(dependencyGraph);
            dependencyGraph.forEach(function (eachEntry) {
                // var entry = eachEntry.entry;
                // var graphPath = path.join(entry, 'dependencyGraph.json');
                var graphPath = 'dependencyGraph.json';
                compilation.assets[graphPath] = {
                    'source': function () {
                        return dependencyGraphJsonStr
                    },
                    'size': function () {
                        return dependencyGraphJsonStr.length;
                    }
                };
                var outputPath = path.join(compilation.outputOptions.path, graphPath);
                console.log("\nPrepare to generate dependency graph in " + outputPath);
            });
            callback();
        } else {
            // 版本冲突 不执行callback，即不生成任何文件，终止打包
            console.error('---Version conflict---');
            result.msg.forEach(function (msg) {
                console.log(msg);
            })
            console.log('---End bundle! Please make sure your libs has no version conflict!---');
            console.log('---If you have any questions, please contact zihao5@staff.sina.com.cn---');
        }

    });
};

module.exports = moduleDependency;