/**
 * 返回指定精度整型随机数
 * @param  {Number} min 左边距
 * @param  {Number} max 右边距
 * @return {Number}   指定范围随机数
 * random(1, 3)  // 1 | 2 | 3
 */
function random(min = 0, max = 1) {
  return Math.floor(Math.random() * (max - min + 1) + min)
}

/**
 * 原生选择器
 * @return {Element} 匹配元素列表
 * e.g.
 * q('.name')  // Element
 * q('.name', '.profile')  // Element
 */
function q() {
  return document.querySelectorAll.apply(document, arguments)
}

/**
 * 获取url参数
 * @param  {String} name 参数名
 * @return {String}      参数值
 * e.g.
 * // http://www.vv314.com?type=1&id=1
 * getUrlParam('id')  // 1
 * getUrlParam('name')  // null
 */
function getUrlParam(name) {
  const reg = new RegExp('(^|&)' + name + '=([^&]*)(&|$)')
  const value = window.location.search.substr(1).match(reg)

  return value === null ? null : decodeURI(value[2])
}

/**
 * 判断是否为微信浏览器
 * @return {Boolean}
 */
function isWechat() {
  const ua = navigator.userAgent.toLowerCase()
  return ua.match(/MicroMessenger/i) === 'micromessenger'
}

/**
 * 字符串超出截取，以省略号结尾
 * @param  {String} str    待截取字符串
 * @param  {Number} maxlength 长度
 * @return {String}        截取结果
 * e.g.
 * limitStr('abcdefg', 4) // abcd...
 */
function limitStr(str, maxlength) {
  return str.length > maxlength ? str.substr(0, maxlength) + '...' : str
}

/**
 * 设置/获取 localStorage
 * 当 value 缺省时为获取数据, value 为对象时,执行序列化
 * @param  {String} name  数据名
 * @param  {String} [value] 数据项
 * e.g.
 * storage('goodid')  // 获取 goodid
 * storage('profile', {name: fish, gender: 1})  // 存储 profile
 */
function storage(name, value) {
  let data = ''

  if (arguments.length === 1) {
    data = localStorage.getItem(name)
    try {
      return JSON.parse(data)
    } catch (e) {
      return data
    }
  } else {
    localStorage.setItem(
      name,
      typeof value === 'object' ? JSON.stringify(value) : value
    )
  }
}

/**
 * 判断字符串、数组、对象内容是否为空
 * @param  {String | Obejct}  obj  数据源
 * @return {Boolean}  判断结果
 * e.g.
 * isEmpty('')  // true
 * isEmpty([])  // true
 * isEmpty({})  // true
 * isEmpty({name: 'fish'})  // false
 */
function isEmpty(obj) {
  switch (typeof obj) {
    case 'undefined':
      return true
    case 'string':
      return !obj.length
    case 'object':
      return obj === null || !Object.keys(obj).length
  }
}

/**
 * 判断是否为数字或数字字符串
 * @param  {Number | String} 数据
 * @return {Boolean}       判断结果
 * e.g.
 * likeNumber(5)  // true
 * likeNumber('8')  // true
 * likeNumber('2a')  // false
 */
function likeNumber(value) {
  return !isNaN(Number(value))
}

/**
 * 邮箱格式验证
 * @param  {String} email  email地址
 * @return {Boolean}  验证结果
 * e.g.
 * vaildEmail('vv314@foxmail.com')  // true
 */
function testEmail(email) {
  var emailRegex = /^([\w-]+(?:\.[\w-]+)*)@((?:[\w-]+\.)*\w[\w-]{0,66})\.([a-z]{2,6}(?:\.[a-z]{2})?)$/i

  return emailRegex.test(email)
}

/**
 * 检查 cookie 是否可用
 * @return {Boolean} true: 支持  false: 不支持
 */
function checkCookie() {
  // 现代浏览器已支持 cookieEnabled
  return !!window.navigator.cookieEnabled
}

/**
 * 获取 Cookie
 * @param  {String} name  cookie名称
 * @return {String}
 * e.g.
 * // cookie: name=fish
 * getCookie('name')  // fish
 * getCookie('age')  // ''
 */
function getCookie(name) {
  const reg = new RegExp(name + '=(.*?)($|;)')
  const value = reg.exec(document.cookie)

  return value === null ? '' : decodeURI(value[1])
}

/**
 * 设置 Cookie
 * @param {String} name   cookie 名
 * @param {String} value  cookie 值
 * @param {Number} days   有效时间
 * @param {String} domain 域名
 */
function setCookie(name, value, days = 15, domain) {
  const exp = new Date()
  const domainStr = domain ? `domain=${domain}` : ''

  exp.setDate(exp.getDate() + days)
  // 调用 encodeURI 对中文及特殊符号编码
  document.cookie = `${name}=${encodeURI(
    value
  )};expires=${exp};path=/;${domainStr}`
}

/**
 * 删除 Cookie
 * @param {String} name  cookie 名称
 * @param {String} domain  域名
 */
function delCookie(name, domain) {
  setCookie(name, '', -1, domain)
}

/**
 * 格式化时间
 * @param  {Date} dateObj Date 对象或时间戳
 * @return {Object}
 */
function parseDate(dateObj) {
  const f = n => (n > 9 ? n : '0' + n)
  const date = dateObj instanceof Date ? dateObj : new Date(dateObj)
  return {
    y: date.getFullYear(),
    M: f(date.getMonth() + 1),
    d: f(date.getDate()),
    h: f(date.getHours()),
    m: f(date.getMinutes()),
    s: f(date.getSeconds())
  }
}

/**
 * 节流函数
 * @param  {Function} method 函数
 * @param  {Number} delay   间隔时间
 * @return {Function}        新函数
 */
function throttle(method, delay) {
  let timer = null

  return function() {
    const args = arguments
    clearTimeout(timer)

    timer = setTimeout(() => {
      method.apply(this, args)
    }, delay)
  }
}

/**
 * 显示时钟
 * @param  {Function} cb         回调函数
 * @param  {Number}   freshTime 刷新时间，毫秒
 * @return {Object}             由 parseDate 返回的时间对象
 */
function realTime(cb, freshTime) {
  cb(parseDate(new Date()))

  return setInterval(() => {
    cb(parseDate(new Date()))
  }, freshTime || 1000)
}

/**
 * 格式化评论数
 * @param  {Number} num [description]
 * @return {String}     [description]
 *
 * e.g
 * reformNum(10000)  // 1万
 */
function reformNum(num = 0) {
  let result = num

  if (!num) return 0

  if (num >= 1000000) {
    result = Math.floor(num / 10000) + '万'
  } else if (num >= 10000) {
    result = Number((num / 10000).toFixed(1)) + '万'
  }

  return result
}

function LoadProto() {
  function load(src, callback) {
    load.js(src, callback)
  }

  load.js = (src, callback) => {
    const id = getIdBySrc(src)
    let el = document.getElementById(id)

    if (el) {
      callback()
    } else {
      el = document.createElement('script')
      el.id = id
      el.src = src

      el.addEventListener('load', function(event) {
        callback(null, event)
      })

      el.addEventListener('error', callback)

      document.body.appendChild(el)
    }

    return el
  }

  load.series = (urls, callback) => {
    var url = urls.shift()

    if (url) {
      load(url, error => {
        error ? callback(error) : load.series(urls, callback)
      })
    } else {
      callback()
    }
  }

  load.parallel = (urls, callback) => {
    let i = urls.length
    let done
    const func = error => {
      --i
      if ((!i && !done) || error) {
        done = true
        callback(error)
      }
    }

    urls.forEach(url => load(url, func))
  }

  function getIdBySrc(src) {
    const isStr = typeof src === 'string'
    let num, sub

    if (!isStr) return

    if (~src.indexOf(':')) {
      src += '-join'
    }

    num = src.lastIndexOf('/') + 1
    sub = src.substr(src, num)
    return src.replace(sub, '').replace(/\./g, '-')
  }

  return load
}

// 加载单个脚本
// load('https://sina.cn/a.js', callback)
//
// 串行加载脚本
// load.series(['https://sina.cn/a.js', 'https://sina.cn/b.js'], callback)
//
// 并行加载脚本
// load.parallel(['https://sina.cn/a.js', 'https://sina.cn/b.js'], callback)
const load = new LoadProto()

/**
 * 检测手势方向
 *
 * e.g
 * var touch = new Touch()
 *
 * touch.listen('#app', function(direction) {
 *   console.log(direction)
 * })
 */
class Touch {
  constructor(threshold = 20) {
    this.isMobile = 'ontouchstart' in window
    this.threshold = threshold
  }

  _getAngle(x, y) {
    return Math.atan2(y, x) * 180 / Math.PI
  }

  start(e) {
    this.startX = this.isMobile ? e.touches[0].pageX : e.x
    this.startY = this.isMobile ? e.touches[0].pageY : e.y
  }

  end(e) {
    this.endX = this.isMobile ? e.changedTouches[0].pageX : e.x
    this.endY = this.isMobile ? e.changedTouches[0].pageY : e.y

    return this._getDirection()
  }

  _getDirection() {
    const angX = this.endX - this.startX
    const angY = this.endY - this.startY
    let result = 'none'

    // 如果滑动距离太短
    if (Math.abs(angX) < this.threshold && Math.abs(angY) < this.threshold)
      return result

    const angle = this._getAngle(angX, angY)

    if (angle >= -135 && angle <= -45) {
      result = 'up'
    } else if (angle > 45 && angle < 135) {
      result = 'down'
    } else if (
      (angle >= 135 && angle <= 180) ||
      (angle >= -180 && angle < -135)
    ) {
      result = 'left'
    } else if (angle >= -45 && angle <= 45) {
      result = 'right'
    }

    return result
  }

  listen(selector, handle) {
    let touchEventsDesktop = { start: 'mousedown', end: 'mouseup' }

    if (window.navigator.pointerEnabled) {
      touchEventsDesktop = { start: 'pointerdown', end: 'pointerup' }
    } else if (window.navigator.msPointerEnabled) {
      touchEventsDesktop = { start: 'MSPointerDown', end: 'MSPointerUp' }
    }

    let touchEvent = {
      start: this.isMobile ? 'touchstart' : touchEventsDesktop.start,
      end: this.isMobile ? 'touchend' : touchEventsDesktop.end
    }

    $(selector).on(touchEvent.start, this.start.bind(this))
    $(selector).on(touchEvent.end, e => handle(this.end(e)))
  }
}

export {
  q,
  load,
  random,
  getUrlParam,
  isWechat,
  limitStr,
  storage,
  isEmpty,
  testEmail,
  likeNumber,
  checkCookie,
  getCookie,
  setCookie,
  delCookie,
  parseDate,
  throttle,
  realTime,
  reformNum,
  Touch
}
