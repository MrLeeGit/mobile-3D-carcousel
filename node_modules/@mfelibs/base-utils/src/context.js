const SID = 'mr-type'

const runtime = {
  // 模块实例集合
  // 在继承了 BaseModule 的组件对象实例化时注册
  // 在 ModuleFactory 自动绑定 DOM 组件时注册
  // {
  //   Foo: [  // 键值为 class name
  //     {
  //        el: Element,
  //        obj: foo,
  //        src: 'obj'
  //     },
  //     {
  //        el: Element,
  //        obj: foo,
  //        src: 'dom'
  //     },
  //     ...
  //   ],
  //   Bar: [{bar1}, {bar2}, ...]
  // }
  instancePool: {
    get length() {
      return Object.keys(runtime.instancePool).length - 1
    }
  },

  // 模块构造器数集合，由 BaseModule.regist 注册
  // {<typeName>: <Class>}
  // {
  //   foo: class Foo,
  //   bar: class Bar
  // }
  classPool: {}
}

const context = {
  // 支持原生对象，Zepto对象，CSS 选择器
  getInstance(selector) {
    const results = queryInstances(selector)

    switch (results.length) {
      case 0:
        return null
      case 1:
        return results[0]['obj']
      default:
        return results.map(mod => mod.obj)
    }
  },

  /**
   * 获取所有通过 BaseModule.regist 注册的类
   * @return {Array} [{class: 'Foo', typeName: 'foo'}]
   */
  showProtoes() {
    return Object.keys(runtime.classPool).map(name => {
      return {
        class: runtime.classPool[name].name,
        typeName: name
      }
    })
  },

  getProto(typeName) {
    return runtime.classPool[typeName]
  },

  destroy(obj) {}
}

/**
 * 将组件初始化后的实例对象注册到 runtime 的实例池中
 * @param  {Module Object} obj 组件对象
 * @param  {Element} el  组件绑定的原生 DOM 元素
 */
function registerRuntime(obj, el) {
  const className = obj.constructor.name
  const conf = {
    obj,
    el,
    className,
    index: getInitedObjIndex(className, el)
  }

  if (conf.index > -1) {
    console.warn(el)
    throw new Error('同一元素不可绑定多个对象')
  } else if (hasInstanceType(className)) {
    patchInstance(conf)
  } else {
    addInstance(conf)
  }
  // console.log(el)
}

function addInstance(ins) {
  Object.defineProperty(runtime.instancePool, ins.className, {
    value: [
      {
        obj: ins.obj,
        el: ins.el,
        src: ins.el['__src'] === 'dom' ? 'dom' : 'obj'
      }
    ],
    writable: false,
    enumerable: true
  })
}

function patchInstance(ins) {
  runtime.instancePool[ins.className].push({
    obj: ins.obj,
    el: ins.el,
    src: ins.el['__src'] === 'dom' ? 'dom' : 'obj'
  })
}

// function replaceInstance(ins) {
//   const instanceList = getInstancesByClassName(ins.className)

//   if (ins.el['__src'] !== 'dom') {
//     instanceList[ins.index].obj = ins.obj
//   }
// }

function hasInstanceType(className) {
  return runtime.instancePool.hasOwnProperty(className)
}

// 根据查找某类别下绑定的实例，未找到索引时，返回 -1
function getInitedObjIndex(className, el) {
  if (!hasInstanceType(className)) return -1

  const instanceList = getInstancesByClassName(className)

  for (let i = 0; i < instanceList.length; i++) {
    if (instanceList[i].el.isEqualNode(el)) return i
  }

  return -1
}

// 当为 dom list 时取第一个元素，包装为 Zepto 对象
// el 非法时，返回 undefined
function getEl(el) {
  const p = $el => ($el.length > 0 ? (($el['__ck'] = true), $el) : void 0)

  switch (true) {
    case el instanceof Element:
      return p($(el))
    case el instanceof NodeList:
      return p($(el[0]))
    case el instanceof HTMLCollection:
      return p($(el[0]))
    case el && el['__ck']:
      return el // $el
    default:
      return p($($(el).get(0))) // Zepto
  }
}

// el 参数类型安全，兼容原生 Element 与 Zepto 对象
function getTypeNameByDOM($el) {
  return $el ? $el.attr(SID) : $el
}

function getClassNameByDOM($el) {
  const typeName = getTypeNameByDOM($el)
  const MClass = context.getProto(typeName)
  return MClass && MClass.name
}

function getInstancesByClassName(name) {
  const objs = runtime.instancePool[name]

  // 始终返回数组，方便遍历使用
  return typeof objs === 'undefined' ? [] : objs
}

function getInstancesByDOM($el) {
  const className = getClassNameByDOM($el)
  return getInstancesByClassName(className)
}

function queryInstances(selector) {
  const $el = getEl(selector)
  const instanceList = getInstancesByDOM($el)

  return instanceList.filter(mod => mod.el.isEqualNode($el[0]))
}

function destroyRuntime(obj) {
  console.log('destroy', obj)
}

export { SID, getEl, runtime, context, registerRuntime, destroyRuntime }
