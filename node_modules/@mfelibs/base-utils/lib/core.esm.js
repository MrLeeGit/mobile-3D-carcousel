/*!
 * @mfelibs/base-utils v1.5.3
 * (c) 2017 Vincent Lee
 * @license MIT
 */
/*! Zepto 1.2.0
 * generated by @sina-mfe
 * modules: zepto event ajax form data callbacks deferred
 */
//     Zepto.js
//     (c) 2010-2016 Thomas Fuchs
//     Zepto.js may be freely distributed under the MIT license.

var Zepto = (function() {
  var undefined, key, $, classList, emptyArray = [], concat = emptyArray.concat, filter = emptyArray.filter, slice = emptyArray.slice,
    document = window.document,
    elementDisplay = {}, classCache = {},
    cssNumber = { 'column-count': 1, 'columns': 1, 'font-weight': 1, 'line-height': 1,'opacity': 1, 'z-index': 1, 'zoom': 1 },
    fragmentRE = /^\s*<(\w+|!)[^>]*>/,
    singleTagRE = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,
    tagExpanderRE = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,
    rootNodeRE = /^(?:body|html)$/i,
    capitalRE = /([A-Z])/g,

    // special attributes that should be get/set via method calls
    methodAttributes = ['val', 'css', 'html', 'text', 'data', 'width', 'height', 'offset'],

    adjacencyOperators = [ 'after', 'prepend', 'before', 'append' ],
    table = document.createElement('table'),
    tableRow = document.createElement('tr'),
    containers = {
      'tr': document.createElement('tbody'),
      'tbody': table, 'thead': table, 'tfoot': table,
      'td': tableRow, 'th': tableRow,
      '*': document.createElement('div')
    },
    simpleSelectorRE = /^[\w-]*$/,
    class2type = {},
    toString = class2type.toString,
    zepto = {},
    camelize, uniq,
    tempParent = document.createElement('div'),
    propMap = {
      'tabindex': 'tabIndex',
      'readonly': 'readOnly',
      'for': 'htmlFor',
      'class': 'className',
      'maxlength': 'maxLength',
      'cellspacing': 'cellSpacing',
      'cellpadding': 'cellPadding',
      'rowspan': 'rowSpan',
      'colspan': 'colSpan',
      'usemap': 'useMap',
      'frameborder': 'frameBorder',
      'contenteditable': 'contentEditable'
    },
    isArray = Array.isArray ||
      function(object){ return object instanceof Array };

  zepto.matches = function(element, selector) {
    if (!selector || !element || element.nodeType !== 1) { return false }
    var matchesSelector = element.matches || element.webkitMatchesSelector ||
                          element.mozMatchesSelector || element.oMatchesSelector ||
                          element.matchesSelector;
    if (matchesSelector) { return matchesSelector.call(element, selector) }
    // fall back to performing a selector:
    var match, parent = element.parentNode, temp = !parent;
    if (temp) { (parent = tempParent).appendChild(element); }
    match = ~zepto.qsa(parent, selector).indexOf(element);
    temp && tempParent.removeChild(element);
    return match
  };

  function type(obj) {
    return obj == null ? String(obj) :
      class2type[toString.call(obj)] || "object"
  }

  function isFunction(value) { return type(value) == "function" }
  function isWindow(obj)     { return obj != null && obj == obj.window }
  function isDocument(obj)   { return obj != null && obj.nodeType == obj.DOCUMENT_NODE }
  function isObject(obj)     { return type(obj) == "object" }
  function isPlainObject(obj) {
    return isObject(obj) && !isWindow(obj) && Object.getPrototypeOf(obj) == Object.prototype
  }

  function likeArray(obj) {
    var length = !!obj && 'length' in obj && obj.length,
      type = $.type(obj);

    return 'function' != type && !isWindow(obj) && (
      'array' == type || length === 0 ||
        (typeof length == 'number' && length > 0 && (length - 1) in obj)
    )
  }

  function compact(array) { return filter.call(array, function(item){ return item != null }) }
  function flatten(array) { return array.length > 0 ? $.fn.concat.apply([], array) : array }
  camelize = function(str){ return str.replace(/-+(.)?/g, function(match, chr){ return chr ? chr.toUpperCase() : '' }) };
  function dasherize(str) {
    return str.replace(/::/g, '/')
           .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')
           .replace(/([a-z\d])([A-Z])/g, '$1_$2')
           .replace(/_/g, '-')
           .toLowerCase()
  }
  uniq = function(array){ return filter.call(array, function(item, idx){ return array.indexOf(item) == idx }) };

  function classRE(name) {
    return name in classCache ?
      classCache[name] : (classCache[name] = new RegExp('(^|\\s)' + name + '(\\s|$)'))
  }

  function maybeAddPx(name, value) {
    return (typeof value == "number" && !cssNumber[dasherize(name)]) ? value + "px" : value
  }

  function defaultDisplay(nodeName) {
    var element, display;
    if (!elementDisplay[nodeName]) {
      element = document.createElement(nodeName);
      document.body.appendChild(element);
      display = getComputedStyle(element, '').getPropertyValue("display");
      element.parentNode.removeChild(element);
      display == "none" && (display = "block");
      elementDisplay[nodeName] = display;
    }
    return elementDisplay[nodeName]
  }

  function children(element) {
    return 'children' in element ?
      slice.call(element.children) :
      $.map(element.childNodes, function(node){ if (node.nodeType == 1) { return node } })
  }

  function Z(dom, selector) {
    var this$1 = this;

    var i, len = dom ? dom.length : 0;
    for (i = 0; i < len; i++) { this$1[i] = dom[i]; }
    this.length = len;
    this.selector = selector || '';
  }

  // `$.zepto.fragment` takes a html string and an optional tag name
  // to generate DOM nodes from the given html string.
  // The generated DOM nodes are returned as an array.
  // This function can be overridden in plugins for example to make
  // it compatible with browsers that don't support the DOM fully.
  zepto.fragment = function(html, name, properties) {
    var dom, nodes, container;

    // A special case optimization for a single tag
    if (singleTagRE.test(html)) { dom = $(document.createElement(RegExp.$1)); }

    if (!dom) {
      if (html.replace) { html = html.replace(tagExpanderRE, "<$1></$2>"); }
      if (name === undefined) { name = fragmentRE.test(html) && RegExp.$1; }
      if (!(name in containers)) { name = '*'; }

      container = containers[name];
      container.innerHTML = '' + html;
      dom = $.each(slice.call(container.childNodes), function(){
        container.removeChild(this);
      });
    }

    if (isPlainObject(properties)) {
      nodes = $(dom);
      $.each(properties, function(key, value) {
        if (methodAttributes.indexOf(key) > -1) { nodes[key](value); }
        else { nodes.attr(key, value); }
      });
    }

    return dom
  };

  // `$.zepto.Z` swaps out the prototype of the given `dom` array
  // of nodes with `$.fn` and thus supplying all the Zepto functions
  // to the array. This method can be overridden in plugins.
  zepto.Z = function(dom, selector) {
    return new Z(dom, selector)
  };

  // `$.zepto.isZ` should return `true` if the given object is a Zepto
  // collection. This method can be overridden in plugins.
  zepto.isZ = function(object) {
    return object instanceof zepto.Z
  };

  // `$.zepto.init` is Zepto's counterpart to jQuery's `$.fn.init` and
  // takes a CSS selector and an optional context (and handles various
  // special cases).
  // This method can be overridden in plugins.
  zepto.init = function(selector, context) {
    var dom;
    // If nothing given, return an empty Zepto collection
    if (!selector) { return zepto.Z() }
    // Optimize for string selectors
    else if (typeof selector == 'string') {
      selector = selector.trim();
      // If it's a html fragment, create nodes from it
      // Note: In both Chrome 21 and Firefox 15, DOM error 12
      // is thrown if the fragment doesn't begin with <
      if (selector[0] == '<' && fragmentRE.test(selector))
        { dom = zepto.fragment(selector, RegExp.$1, context), selector = null; }
      // If there's a context, create a collection on that context first, and select
      // nodes from there
      else if (context !== undefined) { return $(context).find(selector) }
      // If it's a CSS selector, use it to select nodes.
      else { dom = zepto.qsa(document, selector); }
    }
    // If a function is given, call it when the DOM is ready
    else if (isFunction(selector)) { return $(document).ready(selector) }
    // If a Zepto collection is given, just return it
    else if (zepto.isZ(selector)) { return selector }
    else {
      // normalize array if an array of nodes is given
      if (isArray(selector)) { dom = compact(selector); }
      // Wrap DOM nodes.
      else if (isObject(selector))
        { dom = [selector], selector = null; }
      // If it's a html fragment, create nodes from it
      else if (fragmentRE.test(selector))
        { dom = zepto.fragment(selector.trim(), RegExp.$1, context), selector = null; }
      // If there's a context, create a collection on that context first, and select
      // nodes from there
      else if (context !== undefined) { return $(context).find(selector) }
      // And last but no least, if it's a CSS selector, use it to select nodes.
      else { dom = zepto.qsa(document, selector); }
    }
    // create a new Zepto collection from the nodes found
    return zepto.Z(dom, selector)
  };

  // `$` will be the base `Zepto` object. When calling this
  // function just call `$.zepto.init, which makes the implementation
  // details of selecting nodes and creating Zepto collections
  // patchable in plugins.
  $ = function(selector, context){
    return zepto.init(selector, context)
  };

  function extend(target, source, deep) {
    for (key in source)
      { if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {
        if (isPlainObject(source[key]) && !isPlainObject(target[key]))
          { target[key] = {}; }
        if (isArray(source[key]) && !isArray(target[key]))
          { target[key] = []; }
        extend(target[key], source[key], deep);
      }
      else if (source[key] !== undefined) { target[key] = source[key]; } }
  }

  // Copy all but undefined properties from one or more
  // objects to the `target` object.
  $.extend = function(target){
    var deep, args = slice.call(arguments, 1);
    if (typeof target == 'boolean') {
      deep = target;
      target = args.shift();
    }
    args.forEach(function(arg){ extend(target, arg, deep); });
    return target
  };

  // `$.zepto.qsa` is Zepto's CSS selector implementation which
  // uses `document.querySelectorAll` and optimizes for some special cases, like `#id`.
  // This method can be overridden in plugins.
  zepto.qsa = function(element, selector){
    var found,
        maybeID = selector[0] == '#',
        maybeClass = !maybeID && selector[0] == '.',
        nameOnly = maybeID || maybeClass ? selector.slice(1) : selector, // Ensure that a 1 char tag name still gets checked
        isSimple = simpleSelectorRE.test(nameOnly);
    return (element.getElementById && isSimple && maybeID) ? // Safari DocumentFragment doesn't have getElementById
      ( (found = element.getElementById(nameOnly)) ? [found] : [] ) :
      (element.nodeType !== 1 && element.nodeType !== 9 && element.nodeType !== 11) ? [] :
      slice.call(
        isSimple && !maybeID && element.getElementsByClassName ? // DocumentFragment doesn't have getElementsByClassName/TagName
          maybeClass ? element.getElementsByClassName(nameOnly) : // If it's simple, it could be a class
          element.getElementsByTagName(selector) : // Or a tag
          element.querySelectorAll(selector) // Or it's not simple, and we need to query all
      )
  };

  function filtered(nodes, selector) {
    return selector == null ? $(nodes) : $(nodes).filter(selector)
  }

  $.contains = document.documentElement.contains ?
    function(parent, node) {
      return parent !== node && parent.contains(node)
    } :
    function(parent, node) {
      while (node && (node = node.parentNode))
        { if (node === parent) { return true } }
      return false
    };

  function funcArg(context, arg, idx, payload) {
    return isFunction(arg) ? arg.call(context, idx, payload) : arg
  }

  function setAttribute(node, name, value) {
    value == null ? node.removeAttribute(name) : node.setAttribute(name, value);
  }

  // access className property while respecting SVGAnimatedString
  function className(node, value){
    var klass = node.className || '',
        svg   = klass && klass.baseVal !== undefined;

    if (value === undefined) { return svg ? klass.baseVal : klass }
    svg ? (klass.baseVal = value) : (node.className = value);
  }

  // "true"  => true
  // "false" => false
  // "null"  => null
  // "42"    => 42
  // "42.5"  => 42.5
  // "08"    => "08"
  // JSON    => parse if valid
  // String  => self
  function deserializeValue(value) {
    try {
      return value ?
        value == "true" ||
        ( value == "false" ? false :
          value == "null" ? null :
          +value + "" == value ? +value :
          /^[\[\{]/.test(value) ? $.parseJSON(value) :
          value )
        : value
    } catch(e) {
      return value
    }
  }

  $.type = type;
  $.isFunction = isFunction;
  $.isWindow = isWindow;
  $.isArray = isArray;
  $.isPlainObject = isPlainObject;

  $.isEmptyObject = function(obj) {
    var name;
    for (name in obj) { return false }
    return true
  };

  $.isNumeric = function(val) {
    var num = Number(val), type = typeof val;
    return val != null && type != 'boolean' &&
      (type != 'string' || val.length) &&
      !isNaN(num) && isFinite(num) || false
  };

  $.inArray = function(elem, array, i){
    return emptyArray.indexOf.call(array, elem, i)
  };

  $.camelCase = camelize;
  $.trim = function(str) {
    return str == null ? "" : String.prototype.trim.call(str)
  };

  // plugin compatibility
  $.uuid = 0;
  $.support = { };
  $.expr = { };
  $.noop = function() {};

  $.map = function(elements, callback){
    var value, values = [], i, key;
    if (likeArray(elements))
      { for (i = 0; i < elements.length; i++) {
        value = callback(elements[i], i);
        if (value != null) { values.push(value); }
      } }
    else
      { for (key in elements) {
        value = callback(elements[key], key);
        if (value != null) { values.push(value); }
      } }
    return flatten(values)
  };

  $.each = function(elements, callback){
    var i, key;
    if (likeArray(elements)) {
      for (i = 0; i < elements.length; i++)
        { if (callback.call(elements[i], i, elements[i]) === false) { return elements } }
    } else {
      for (key in elements)
        { if (callback.call(elements[key], key, elements[key]) === false) { return elements } }
    }

    return elements
  };

  $.grep = function(elements, callback){
    return filter.call(elements, callback)
  };

  if (window.JSON) { $.parseJSON = JSON.parse; }

  // Populate the class2type map
  $.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
    class2type[ "[object " + name + "]" ] = name.toLowerCase();
  });

  // Define methods that will be available on all
  // Zepto collections
  $.fn = {
    constructor: zepto.Z,
    length: 0,

    // Because a collection acts like an array
    // copy over these useful array functions.
    forEach: emptyArray.forEach,
    reduce: emptyArray.reduce,
    push: emptyArray.push,
    sort: emptyArray.sort,
    splice: emptyArray.splice,
    indexOf: emptyArray.indexOf,
    concat: function(){
      var arguments$1 = arguments;

      var i, value, args = [];
      for (i = 0; i < arguments.length; i++) {
        value = arguments$1[i];
        args[i] = zepto.isZ(value) ? value.toArray() : value;
      }
      return concat.apply(zepto.isZ(this) ? this.toArray() : this, args)
    },

    // `map` and `slice` in the jQuery API work differently
    // from their array counterparts
    map: function(fn){
      return $($.map(this, function(el, i){ return fn.call(el, i, el) }))
    },
    slice: function(){
      return $(slice.apply(this, arguments))
    },

    ready: function(callback){
      // don't use "interactive" on IE <= 10 (it can fired premature)
      if (document.readyState === "complete" ||
          (document.readyState !== "loading" && !document.documentElement.doScroll))
        { setTimeout(function(){ callback($); }, 0); }
      else {
        var handler = function() {
          document.removeEventListener("DOMContentLoaded", handler, false);
          window.removeEventListener("load", handler, false);
          callback($);
        };
        document.addEventListener("DOMContentLoaded", handler, false);
        window.addEventListener("load", handler, false);
      }
      return this
    },
    get: function(idx){
      return idx === undefined ? slice.call(this) : this[idx >= 0 ? idx : idx + this.length]
    },
    toArray: function(){ return this.get() },
    size: function(){
      return this.length
    },
    remove: function(){
      return this.each(function(){
        if (this.parentNode != null)
          { this.parentNode.removeChild(this); }
      })
    },
    each: function(callback){
      emptyArray.every.call(this, function(el, idx){
        return callback.call(el, idx, el) !== false
      });
      return this
    },
    filter: function(selector){
      if (isFunction(selector)) { return this.not(this.not(selector)) }
      return $(filter.call(this, function(element){
        return zepto.matches(element, selector)
      }))
    },
    add: function(selector,context){
      return $(uniq(this.concat($(selector,context))))
    },
    is: function(selector){
      return this.length > 0 && zepto.matches(this[0], selector)
    },
    not: function(selector){
      var nodes=[];
      if (isFunction(selector) && selector.call !== undefined)
        { this.each(function(idx){
          if (!selector.call(this,idx)) { nodes.push(this); }
        }); }
      else {
        var excludes = typeof selector == 'string' ? this.filter(selector) :
          (likeArray(selector) && isFunction(selector.item)) ? slice.call(selector) : $(selector);
        this.forEach(function(el){
          if (excludes.indexOf(el) < 0) { nodes.push(el); }
        });
      }
      return $(nodes)
    },
    has: function(selector){
      return this.filter(function(){
        return isObject(selector) ?
          $.contains(this, selector) :
          $(this).find(selector).size()
      })
    },
    eq: function(idx){
      return idx === -1 ? this.slice(idx) : this.slice(idx, + idx + 1)
    },
    first: function(){
      var el = this[0];
      return el && !isObject(el) ? el : $(el)
    },
    last: function(){
      var el = this[this.length - 1];
      return el && !isObject(el) ? el : $(el)
    },
    find: function(selector){
      var result, $this = this;
      if (!selector) { result = $(); }
      else if (typeof selector == 'object')
        { result = $(selector).filter(function(){
          var node = this;
          return emptyArray.some.call($this, function(parent){
            return $.contains(parent, node)
          })
        }); }
      else if (this.length == 1) { result = $(zepto.qsa(this[0], selector)); }
      else { result = this.map(function(){ return zepto.qsa(this, selector) }); }
      return result
    },
    closest: function(selector, context){
      var nodes = [], collection = typeof selector == 'object' && $(selector);
      this.each(function(_, node){
        while (node && !(collection ? collection.indexOf(node) >= 0 : zepto.matches(node, selector)))
          { node = node !== context && !isDocument(node) && node.parentNode; }
        if (node && nodes.indexOf(node) < 0) { nodes.push(node); }
      });
      return $(nodes)
    },
    parents: function(selector){
      var ancestors = [], nodes = this;
      while (nodes.length > 0)
        { nodes = $.map(nodes, function(node){
          if ((node = node.parentNode) && !isDocument(node) && ancestors.indexOf(node) < 0) {
            ancestors.push(node);
            return node
          }
        }); }
      return filtered(ancestors, selector)
    },
    parent: function(selector){
      return filtered(uniq(this.pluck('parentNode')), selector)
    },
    children: function(selector){
      return filtered(this.map(function(){ return children(this) }), selector)
    },
    contents: function() {
      return this.map(function() { return this.contentDocument || slice.call(this.childNodes) })
    },
    siblings: function(selector){
      return filtered(this.map(function(i, el){
        return filter.call(children(el.parentNode), function(child){ return child!==el })
      }), selector)
    },
    empty: function(){
      return this.each(function(){ this.innerHTML = ''; })
    },
    // `pluck` is borrowed from Prototype.js
    pluck: function(property){
      return $.map(this, function(el){ return el[property] })
    },
    show: function(){
      return this.each(function(){
        this.style.display == "none" && (this.style.display = '');
        if (getComputedStyle(this, '').getPropertyValue("display") == "none")
          { this.style.display = defaultDisplay(this.nodeName); }
      })
    },
    replaceWith: function(newContent){
      return this.before(newContent).remove()
    },
    wrap: function(structure){
      var func = isFunction(structure);
      if (this[0] && !func)
        { var dom   = $(structure).get(0),
            clone = dom.parentNode || this.length > 1; }

      return this.each(function(index){
        $(this).wrapAll(
          func ? structure.call(this, index) :
            clone ? dom.cloneNode(true) : dom
        );
      })
    },
    wrapAll: function(structure){
      if (this[0]) {
        $(this[0]).before(structure = $(structure));
        var children;
        // drill down to the inmost element
        while ((children = structure.children()).length) { structure = children.first(); }
        $(structure).append(this);
      }
      return this
    },
    wrapInner: function(structure){
      var func = isFunction(structure);
      return this.each(function(index){
        var self = $(this), contents = self.contents(),
            dom  = func ? structure.call(this, index) : structure;
        contents.length ? contents.wrapAll(dom) : self.append(dom);
      })
    },
    unwrap: function(){
      this.parent().each(function(){
        $(this).replaceWith($(this).children());
      });
      return this
    },
    clone: function(){
      return this.map(function(){ return this.cloneNode(true) })
    },
    hide: function(){
      return this.css("display", "none")
    },
    toggle: function(setting){
      return this.each(function(){
        var el = $(this);(setting === undefined ? el.css("display") == "none" : setting) ? el.show() : el.hide();
      })
    },
    prev: function(selector){ return $(this.pluck('previousElementSibling')).filter(selector || '*') },
    next: function(selector){ return $(this.pluck('nextElementSibling')).filter(selector || '*') },
    html: function(html){
      return 0 in arguments ?
        this.each(function(idx){
          var originHtml = this.innerHTML;
          $(this).empty().append( funcArg(this, html, idx, originHtml) );
        }) :
        (0 in this ? this[0].innerHTML : null)
    },
    text: function(text){
      return 0 in arguments ?
        this.each(function(idx){
          var newText = funcArg(this, text, idx, this.textContent);
          this.textContent = newText == null ? '' : ''+newText;
        }) :
        (0 in this ? this.pluck('textContent').join("") : null)
    },
    attr: function(name, value){
      var result;
      return (typeof name == 'string' && !(1 in arguments)) ?
        (0 in this && this[0].nodeType == 1 && (result = this[0].getAttribute(name)) != null ? result : undefined) :
        this.each(function(idx){
          var this$1 = this;

          if (this.nodeType !== 1) { return }
          if (isObject(name)) { for (key in name) { setAttribute(this$1, key, name[key]); } }
          else { setAttribute(this, name, funcArg(this, value, idx, this.getAttribute(name))); }
        })
    },
    removeAttr: function(name){
      return this.each(function(){ this.nodeType === 1 && name.split(' ').forEach(function(attribute){
        setAttribute(this, attribute);
      }, this);})
    },
    prop: function(name, value){
      name = propMap[name] || name;
      return (1 in arguments) ?
        this.each(function(idx){
          this[name] = funcArg(this, value, idx, this[name]);
        }) :
        (this[0] && this[0][name])
    },
    removeProp: function(name){
      name = propMap[name] || name;
      return this.each(function(){ delete this[name]; })
    },
    data: function(name, value){
      var attrName = 'data-' + name.replace(capitalRE, '-$1').toLowerCase();

      var data = (1 in arguments) ?
        this.attr(attrName, value) :
        this.attr(attrName);

      return data !== null ? deserializeValue(data) : undefined
    },
    val: function(value){
      if (0 in arguments) {
        if (value == null) { value = ""; }
        return this.each(function(idx){
          this.value = funcArg(this, value, idx, this.value);
        })
      } else {
        return this[0] && (this[0].multiple ?
           $(this[0]).find('option').filter(function(){ return this.selected }).pluck('value') :
           this[0].value)
      }
    },
    offset: function(coordinates){
      if (coordinates) { return this.each(function(index){
        var $this = $(this),
            coords = funcArg(this, coordinates, index, $this.offset()),
            parentOffset = $this.offsetParent().offset(),
            props = {
              top:  coords.top  - parentOffset.top,
              left: coords.left - parentOffset.left
            };

        if ($this.css('position') == 'static') { props['position'] = 'relative'; }
        $this.css(props);
      }) }
      if (!this.length) { return null }
      if (document.documentElement !== this[0] && !$.contains(document.documentElement, this[0]))
        { return {top: 0, left: 0} }
      var obj = this[0].getBoundingClientRect();
      return {
        left: obj.left + window.pageXOffset,
        top: obj.top + window.pageYOffset,
        width: Math.round(obj.width),
        height: Math.round(obj.height)
      }
    },
    css: function(property, value){
      var this$1 = this;

      if (arguments.length < 2) {
        var element = this[0];
        if (typeof property == 'string') {
          if (!element) { return }
          return element.style[camelize(property)] || getComputedStyle(element, '').getPropertyValue(property)
        } else if (isArray(property)) {
          if (!element) { return }
          var props = {};
          var computedStyle = getComputedStyle(element, '');
          $.each(property, function(_, prop){
            props[prop] = (element.style[camelize(prop)] || computedStyle.getPropertyValue(prop));
          });
          return props
        }
      }

      var css = '';
      if (type(property) == 'string') {
        if (!value && value !== 0)
          { this.each(function(){ this.style.removeProperty(dasherize(property)); }); }
        else
          { css = dasherize(property) + ":" + maybeAddPx(property, value); }
      } else {
        for (key in property)
          { if (!property[key] && property[key] !== 0)
            { this$1.each(function(){ this.style.removeProperty(dasherize(key)); }); }
          else
            { css += dasherize(key) + ':' + maybeAddPx(key, property[key]) + ';'; } }
      }

      return this.each(function(){ this.style.cssText += ';' + css; })
    },
    index: function(element){
      return element ? this.indexOf($(element)[0]) : this.parent().children().indexOf(this[0])
    },
    hasClass: function(name){
      if (!name) { return false }
      return emptyArray.some.call(this, function(el){
        return this.test(className(el))
      }, classRE(name))
    },
    addClass: function(name){
      if (!name) { return this }
      return this.each(function(idx){
        if (!('className' in this)) { return }
        classList = [];
        var cls = className(this), newName = funcArg(this, name, idx, cls);
        newName.split(/\s+/g).forEach(function(klass){
          if (!$(this).hasClass(klass)) { classList.push(klass); }
        }, this);
        classList.length && className(this, cls + (cls ? " " : "") + classList.join(" "));
      })
    },
    removeClass: function(name){
      return this.each(function(idx){
        if (!('className' in this)) { return }
        if (name === undefined) { return className(this, '') }
        classList = className(this);
        funcArg(this, name, idx, classList).split(/\s+/g).forEach(function(klass){
          classList = classList.replace(classRE(klass), " ");
        });
        className(this, classList.trim());
      })
    },
    toggleClass: function(name, when){
      if (!name) { return this }
      return this.each(function(idx){
        var $this = $(this), names = funcArg(this, name, idx, className(this));
        names.split(/\s+/g).forEach(function(klass){
          (when === undefined ? !$this.hasClass(klass) : when) ?
            $this.addClass(klass) : $this.removeClass(klass);
        });
      })
    },
    scrollTop: function(value){
      if (!this.length) { return }
      var hasScrollTop = 'scrollTop' in this[0];
      if (value === undefined) { return hasScrollTop ? this[0].scrollTop : this[0].pageYOffset }
      return this.each(hasScrollTop ?
        function(){ this.scrollTop = value; } :
        function(){ this.scrollTo(this.scrollX, value); })
    },
    scrollLeft: function(value){
      if (!this.length) { return }
      var hasScrollLeft = 'scrollLeft' in this[0];
      if (value === undefined) { return hasScrollLeft ? this[0].scrollLeft : this[0].pageXOffset }
      return this.each(hasScrollLeft ?
        function(){ this.scrollLeft = value; } :
        function(){ this.scrollTo(value, this.scrollY); })
    },
    position: function() {
      if (!this.length) { return }

      var elem = this[0],
        // Get *real* offsetParent
        offsetParent = this.offsetParent(),
        // Get correct offsets
        offset       = this.offset(),
        parentOffset = rootNodeRE.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();

      // Subtract element margins
      // note: when an element has margin: auto the offsetLeft and marginLeft
      // are the same in Safari causing offset.left to incorrectly be 0
      offset.top  -= parseFloat( $(elem).css('margin-top') ) || 0;
      offset.left -= parseFloat( $(elem).css('margin-left') ) || 0;

      // Add offsetParent borders
      parentOffset.top  += parseFloat( $(offsetParent[0]).css('border-top-width') ) || 0;
      parentOffset.left += parseFloat( $(offsetParent[0]).css('border-left-width') ) || 0;

      // Subtract the two offsets
      return {
        top:  offset.top  - parentOffset.top,
        left: offset.left - parentOffset.left
      }
    },
    offsetParent: function() {
      return this.map(function(){
        var parent = this.offsetParent || document.body;
        while (parent && !rootNodeRE.test(parent.nodeName) && $(parent).css("position") == "static")
          { parent = parent.offsetParent; }
        return parent
      })
    }
  };

  // for now
  $.fn.detach = $.fn.remove

  // Generate the `width` and `height` functions
  ;['width', 'height'].forEach(function(dimension){
    var dimensionProperty =
      dimension.replace(/./, function(m){ return m[0].toUpperCase() });

    $.fn[dimension] = function(value){
      var offset, el = this[0];
      if (value === undefined) { return isWindow(el) ? el['inner' + dimensionProperty] :
        isDocument(el) ? el.documentElement['scroll' + dimensionProperty] :
        (offset = this.offset()) && offset[dimension] }
      else { return this.each(function(idx){
        el = $(this);
        el.css(dimension, funcArg(this, value, idx, el[dimension]()));
      }) }
    };
  });

  function traverseNode(node, fun) {
    fun(node);
    for (var i = 0, len = node.childNodes.length; i < len; i++)
      { traverseNode(node.childNodes[i], fun); }
  }

  // Generate the `after`, `prepend`, `before`, `append`,
  // `insertAfter`, `insertBefore`, `appendTo`, and `prependTo` methods.
  adjacencyOperators.forEach(function(operator, operatorIndex) {
    var inside = operatorIndex % 2; //=> prepend, append

    $.fn[operator] = function(){
      // arguments can be nodes, arrays of nodes, Zepto objects and HTML strings
      var argType, nodes = $.map(arguments, function(arg) {
            var arr = [];
            argType = type(arg);
            if (argType == "array") {
              arg.forEach(function(el) {
                if (el.nodeType !== undefined) { return arr.push(el) }
                else if ($.zepto.isZ(el)) { return arr = arr.concat(el.get()) }
                arr = arr.concat(zepto.fragment(el));
              });
              return arr
            }
            return argType == "object" || arg == null ?
              arg : zepto.fragment(arg)
          }),
          parent, copyByClone = this.length > 1;
      if (nodes.length < 1) { return this }

      return this.each(function(_, target){
        parent = inside ? target : target.parentNode;

        // convert all methods to a "before" operation
        target = operatorIndex == 0 ? target.nextSibling :
                 operatorIndex == 1 ? target.firstChild :
                 operatorIndex == 2 ? target :
                 null;

        var parentInDocument = $.contains(document.documentElement, parent);

        nodes.forEach(function(node){
          if (copyByClone) { node = node.cloneNode(true); }
          else if (!parent) { return $(node).remove() }

          parent.insertBefore(node, target);
          if (parentInDocument) { traverseNode(node, function(el){
            if (el.nodeName != null && el.nodeName.toUpperCase() === 'SCRIPT' &&
               (!el.type || el.type === 'text/javascript') && !el.src){
              var target = el.ownerDocument ? el.ownerDocument.defaultView : window;
              target['eval'].call(target, el.innerHTML);
            }
          }); }
        });
      })
    };

    // after    => insertAfter
    // prepend  => prependTo
    // before   => insertBefore
    // append   => appendTo
    $.fn[inside ? operator+'To' : 'insert'+(operatorIndex ? 'Before' : 'After')] = function(html){
      $(html)[operator](this);
      return this
    };
  });

  zepto.Z.prototype = Z.prototype = $.fn;

  // Export internal API functions in the `$.zepto` namespace
  zepto.uniq = uniq;
  zepto.deserializeValue = deserializeValue;
  $.zepto = zepto;

  return $
})();

// If `$` is not yet defined, point it to `Zepto`
window.Zepto = Zepto;
window.$ === undefined && (window.$ = Zepto)

//     Zepto.js
//     (c) 2010-2016 Thomas Fuchs
//     Zepto.js may be freely distributed under the MIT license.

;(function($){
  var _zid = 1, undefined,
      slice = Array.prototype.slice,
      isFunction = $.isFunction,
      isString = function(obj){ return typeof obj == 'string' },
      handlers = {},
      specialEvents={},
      focusinSupported = 'onfocusin' in window,
      focus = { focus: 'focusin', blur: 'focusout' },
      hover = { mouseenter: 'mouseover', mouseleave: 'mouseout' };

  specialEvents.click = specialEvents.mousedown = specialEvents.mouseup = specialEvents.mousemove = 'MouseEvents';

  function zid(element) {
    return element._zid || (element._zid = _zid++)
  }
  function findHandlers(element, event, fn, selector) {
    event = parse(event);
    if (event.ns) { var matcher = matcherFor(event.ns); }
    return (handlers[zid(element)] || []).filter(function(handler) {
      return handler
        && (!event.e  || handler.e == event.e)
        && (!event.ns || matcher.test(handler.ns))
        && (!fn       || zid(handler.fn) === zid(fn))
        && (!selector || handler.sel == selector)
    })
  }
  function parse(event) {
    var parts = ('' + event).split('.');
    return {e: parts[0], ns: parts.slice(1).sort().join(' ')}
  }
  function matcherFor(ns) {
    return new RegExp('(?:^| )' + ns.replace(' ', ' .* ?') + '(?: |$)')
  }

  function eventCapture(handler, captureSetting) {
    return handler.del &&
      (!focusinSupported && (handler.e in focus)) ||
      !!captureSetting
  }

  function realEvent(type) {
    return hover[type] || (focusinSupported && focus[type]) || type
  }

  function add(element, events, fn, data, selector, delegator, capture){
    var id = zid(element), set = (handlers[id] || (handlers[id] = []));
    events.split(/\s/).forEach(function(event){
      if (event == 'ready') { return $(document).ready(fn) }
      var handler   = parse(event);
      handler.fn    = fn;
      handler.sel   = selector;
      // emulate mouseenter, mouseleave
      if (handler.e in hover) { fn = function(e){
        var related = e.relatedTarget;
        if (!related || (related !== this && !$.contains(this, related)))
          { return handler.fn.apply(this, arguments) }
      }; }
      handler.del   = delegator;
      var callback  = delegator || fn;
      handler.proxy = function(e){
        e = compatible(e);
        if (e.isImmediatePropagationStopped()) { return }
        e.data = data;
        var result = callback.apply(element, e._args == undefined ? [e] : [e].concat(e._args));
        if (result === false) { e.preventDefault(), e.stopPropagation(); }
        return result
      };
      handler.i = set.length;
      set.push(handler);
      if ('addEventListener' in element)
        { element.addEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture)); }
    });
  }
  function remove(element, events, fn, selector, capture){
    var id = zid(element);(events || '').split(/\s/).forEach(function(event){
      findHandlers(element, event, fn, selector).forEach(function(handler){
        delete handlers[id][handler.i];
      if ('removeEventListener' in element)
        { element.removeEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture)); }
      });
    });
  }

  $.event = { add: add, remove: remove };

  $.proxy = function(fn, context) {
    var args = (2 in arguments) && slice.call(arguments, 2);
    if (isFunction(fn)) {
      var proxyFn = function(){ return fn.apply(context, args ? args.concat(slice.call(arguments)) : arguments) };
      proxyFn._zid = zid(fn);
      return proxyFn
    } else if (isString(context)) {
      if (args) {
        args.unshift(fn[context], fn);
        return $.proxy.apply(null, args)
      } else {
        return $.proxy(fn[context], fn)
      }
    } else {
      throw new TypeError("expected function")
    }
  };

  $.fn.bind = function(event, data, callback){
    return this.on(event, data, callback)
  };
  $.fn.unbind = function(event, callback){
    return this.off(event, callback)
  };
  $.fn.one = function(event, selector, data, callback){
    return this.on(event, selector, data, callback, 1)
  };

  var returnTrue = function(){return true},
      returnFalse = function(){return false},
      ignoreProperties = /^([A-Z]|returnValue$|layer[XY]$|webkitMovement[XY]$)/,
      eventMethods = {
        preventDefault: 'isDefaultPrevented',
        stopImmediatePropagation: 'isImmediatePropagationStopped',
        stopPropagation: 'isPropagationStopped'
      };

  function compatible(event, source) {
    if (source || !event.isDefaultPrevented) {
      source || (source = event);

      $.each(eventMethods, function(name, predicate) {
        var sourceMethod = source[name];
        event[name] = function(){
          this[predicate] = returnTrue;
          return sourceMethod && sourceMethod.apply(source, arguments)
        };
        event[predicate] = returnFalse;
      });

      try {
        event.timeStamp || (event.timeStamp = Date.now());
      } catch (ignored) { }

      if (source.defaultPrevented !== undefined ? source.defaultPrevented :
          'returnValue' in source ? source.returnValue === false :
          source.getPreventDefault && source.getPreventDefault())
        { event.isDefaultPrevented = returnTrue; }
    }
    return event
  }

  function createProxy(event) {
    var key, proxy = { originalEvent: event };
    for (key in event)
      { if (!ignoreProperties.test(key) && event[key] !== undefined) { proxy[key] = event[key]; } }

    return compatible(proxy, event)
  }

  $.fn.delegate = function(selector, event, callback){
    return this.on(event, selector, callback)
  };
  $.fn.undelegate = function(selector, event, callback){
    return this.off(event, selector, callback)
  };

  $.fn.live = function(event, callback){
    $(document.body).delegate(this.selector, event, callback);
    return this
  };
  $.fn.die = function(event, callback){
    $(document.body).undelegate(this.selector, event, callback);
    return this
  };

  $.fn.on = function(event, selector, data, callback, one){
    var autoRemove, delegator, $this = this;
    if (event && !isString(event)) {
      $.each(event, function(type, fn){
        $this.on(type, selector, data, fn, one);
      });
      return $this
    }

    if (!isString(selector) && !isFunction(callback) && callback !== false)
      { callback = data, data = selector, selector = undefined; }
    if (callback === undefined || data === false)
      { callback = data, data = undefined; }

    if (callback === false) { callback = returnFalse; }

    return $this.each(function(_, element){
      if (one) { autoRemove = function(e){
        remove(element, e.type, callback);
        return callback.apply(this, arguments)
      }; }

      if (selector) { delegator = function(e){
        var evt, match = $(e.target).closest(selector, element).get(0);
        if (match && match !== element) {
          evt = $.extend(createProxy(e), {currentTarget: match, liveFired: element});
          return (autoRemove || callback).apply(match, [evt].concat(slice.call(arguments, 1)))
        }
      }; }

      add(element, event, callback, data, selector, delegator || autoRemove);
    })
  };
  $.fn.off = function(event, selector, callback){
    var $this = this;
    if (event && !isString(event)) {
      $.each(event, function(type, fn){
        $this.off(type, selector, fn);
      });
      return $this
    }

    if (!isString(selector) && !isFunction(callback) && callback !== false)
      { callback = selector, selector = undefined; }

    if (callback === false) { callback = returnFalse; }

    return $this.each(function(){
      remove(this, event, callback, selector);
    })
  };

  $.fn.trigger = function(event, args){
    event = (isString(event) || $.isPlainObject(event)) ? $.Event(event) : compatible(event);
    event._args = args;
    return this.each(function(){
      // handle focus(), blur() by calling them directly
      if (event.type in focus && typeof this[event.type] == "function") { this[event.type](); }
      // items in the collection might not be DOM elements
      else if ('dispatchEvent' in this) { this.dispatchEvent(event); }
      else { $(this).triggerHandler(event, args); }
    })
  };

  // triggers event handlers on current element just as if an event occurred,
  // doesn't trigger an actual event, doesn't bubble
  $.fn.triggerHandler = function(event, args){
    var e, result;
    this.each(function(i, element){
      e = createProxy(isString(event) ? $.Event(event) : event);
      e._args = args;
      e.target = element;
      $.each(findHandlers(element, event.type || event), function(i, handler){
        result = handler.proxy(e);
        if (e.isImmediatePropagationStopped()) { return false }
      });
    });
    return result
  }

  // shortcut methods for `.bind(event, fn)` for each event type
  ;('focusin focusout focus blur load resize scroll unload click dblclick '+
  'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave '+
  'change select keydown keypress keyup error').split(' ').forEach(function(event) {
    $.fn[event] = function(callback) {
      return (0 in arguments) ?
        this.bind(event, callback) :
        this.trigger(event)
    };
  });

  $.Event = function(type, props) {
    if (!isString(type)) { props = type, type = props.type; }
    var event = document.createEvent(specialEvents[type] || 'Events'), bubbles = true;
    if (props) { for (var name in props) { (name == 'bubbles') ? (bubbles = !!props[name]) : (event[name] = props[name]); } }
    event.initEvent(type, bubbles, true);
    return compatible(event)
  };

})(Zepto)

//     Zepto.js
//     (c) 2010-2016 Thomas Fuchs
//     Zepto.js may be freely distributed under the MIT license.

;(function($){
  var jsonpID = +new Date(),
      document = window.document,
      key,
      name,
      rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
      scriptTypeRE = /^(?:text|application)\/javascript/i,
      xmlTypeRE = /^(?:text|application)\/xml/i,
      jsonType = 'application/json',
      htmlType = 'text/html',
      blankRE = /^\s*$/,
      originAnchor = document.createElement('a');

  originAnchor.href = window.location.href;

  // trigger a custom event and return false if it was cancelled
  function triggerAndReturn(context, eventName, data) {
    var event = $.Event(eventName);
    $(context).trigger(event, data);
    return !event.isDefaultPrevented()
  }

  // trigger an Ajax "global" event
  function triggerGlobal(settings, context, eventName, data) {
    if (settings.global) { return triggerAndReturn(context || document, eventName, data) }
  }

  // Number of active Ajax requests
  $.active = 0;

  function ajaxStart(settings) {
    if (settings.global && $.active++ === 0) { triggerGlobal(settings, null, 'ajaxStart'); }
  }
  function ajaxStop(settings) {
    if (settings.global && !(--$.active)) { triggerGlobal(settings, null, 'ajaxStop'); }
  }

  // triggers an extra global event "ajaxBeforeSend" that's like "ajaxSend" but cancelable
  function ajaxBeforeSend(xhr, settings) {
    var context = settings.context;
    if (settings.beforeSend.call(context, xhr, settings) === false ||
        triggerGlobal(settings, context, 'ajaxBeforeSend', [xhr, settings]) === false)
      { return false }

    triggerGlobal(settings, context, 'ajaxSend', [xhr, settings]);
  }
  function ajaxSuccess(data, xhr, settings, deferred) {
    var context = settings.context, status = 'success';
    settings.success.call(context, data, status, xhr);
    if (deferred) { deferred.resolveWith(context, [data, status, xhr]); }
    triggerGlobal(settings, context, 'ajaxSuccess', [xhr, settings, data]);
    ajaxComplete(status, xhr, settings);
  }
  // type: "timeout", "error", "abort", "parsererror"
  function ajaxError(error, type, xhr, settings, deferred) {
    var context = settings.context;
    settings.error.call(context, xhr, type, error);
    if (deferred) { deferred.rejectWith(context, [xhr, type, error]); }
    triggerGlobal(settings, context, 'ajaxError', [xhr, settings, error || type]);
    ajaxComplete(type, xhr, settings);
  }
  // status: "success", "notmodified", "error", "timeout", "abort", "parsererror"
  function ajaxComplete(status, xhr, settings) {
    var context = settings.context;
    settings.complete.call(context, xhr, status);
    triggerGlobal(settings, context, 'ajaxComplete', [xhr, settings]);
    ajaxStop(settings);
  }

  function ajaxDataFilter(data, type, settings) {
    if (settings.dataFilter == empty) { return data }
    var context = settings.context;
    return settings.dataFilter.call(context, data, type)
  }

  // Empty function, used as default callback
  function empty() {}

  $.ajaxJSONP = function(options, deferred){
    if (!('type' in options)) { return $.ajax(options) }

    var _callbackName = options.jsonpCallback,
      callbackName = ($.isFunction(_callbackName) ?
        _callbackName() : _callbackName) || ('Zepto' + (jsonpID++)),
      script = document.createElement('script'),
      originalCallback = window[callbackName],
      responseData,
      abort = function(errorType) {
        $(script).triggerHandler('error', errorType || 'abort');
      },
      xhr = { abort: abort }, abortTimeout;

    if (deferred) { deferred.promise(xhr); }

    $(script).on('load error', function(e, errorType){
      clearTimeout(abortTimeout);
      $(script).off().remove();

      if (e.type == 'error' || !responseData) {
        ajaxError(null, errorType || 'error', xhr, options, deferred);
      } else {
        ajaxSuccess(responseData[0], xhr, options, deferred);
      }

      window[callbackName] = originalCallback;
      if (responseData && $.isFunction(originalCallback))
        { originalCallback(responseData[0]); }

      originalCallback = responseData = undefined;
    });

    if (ajaxBeforeSend(xhr, options) === false) {
      abort('abort');
      return xhr
    }

    window[callbackName] = function(){
      responseData = arguments;
    };

    script.src = options.url.replace(/\?(.+)=\?/, '?$1=' + callbackName);
    document.head.appendChild(script);

    if (options.timeout > 0) { abortTimeout = setTimeout(function(){
      abort('timeout');
    }, options.timeout); }

    return xhr
  };

  $.ajaxSettings = {
    // Default type of request
    type: 'GET',
    // Callback that is executed before request
    beforeSend: empty,
    // Callback that is executed if the request succeeds
    success: empty,
    // Callback that is executed the the server drops error
    error: empty,
    // Callback that is executed on request complete (both: error and success)
    complete: empty,
    // The context for the callbacks
    context: null,
    // Whether to trigger "global" Ajax events
    global: true,
    // Transport
    xhr: function () {
      return new window.XMLHttpRequest()
    },
    // MIME types mapping
    // IIS returns Javascript as "application/x-javascript"
    accepts: {
      script: 'text/javascript, application/javascript, application/x-javascript',
      json:   jsonType,
      xml:    'application/xml, text/xml',
      html:   htmlType,
      text:   'text/plain'
    },
    // Whether the request is to another domain
    crossDomain: false,
    // Default timeout
    timeout: 0,
    // Whether data should be serialized to string
    processData: true,
    // Whether the browser should be allowed to cache GET responses
    cache: true,
    //Used to handle the raw response data of XMLHttpRequest.
    //This is a pre-filtering function to sanitize the response.
    //The sanitized response should be returned
    dataFilter: empty
  };

  function mimeToDataType(mime) {
    if (mime) { mime = mime.split(';', 2)[0]; }
    return mime && ( mime == htmlType ? 'html' :
      mime == jsonType ? 'json' :
      scriptTypeRE.test(mime) ? 'script' :
      xmlTypeRE.test(mime) && 'xml' ) || 'text'
  }

  function appendQuery(url, query) {
    if (query == '') { return url }
    return (url + '&' + query).replace(/[&?]{1,2}/, '?')
  }

  // serialize payload and append it to the URL for GET requests
  function serializeData(options) {
    if (options.processData && options.data && $.type(options.data) != "string")
      { options.data = $.param(options.data, options.traditional); }
    if (options.data && (!options.type || options.type.toUpperCase() == 'GET' || 'jsonp' == options.dataType))
      { options.url = appendQuery(options.url, options.data), options.data = undefined; }
  }

  $.ajax = function(options){
    var settings = $.extend({}, options || {}),
        deferred = $.Deferred && $.Deferred(),
        urlAnchor, hashIndex;
    for (key in $.ajaxSettings) { if (settings[key] === undefined) { settings[key] = $.ajaxSettings[key]; } }

    ajaxStart(settings);

    if (!settings.crossDomain) {
      urlAnchor = document.createElement('a');
      urlAnchor.href = settings.url;
      // cleans up URL for .href (IE only), see https://github.com/madrobby/zepto/pull/1049
      urlAnchor.href = urlAnchor.href;
      settings.crossDomain = (originAnchor.protocol + '//' + originAnchor.host) !== (urlAnchor.protocol + '//' + urlAnchor.host);
    }

    if (!settings.url) { settings.url = window.location.toString(); }
    if ((hashIndex = settings.url.indexOf('#')) > -1) { settings.url = settings.url.slice(0, hashIndex); }
    serializeData(settings);

    var dataType = settings.dataType, hasPlaceholder = /\?.+=\?/.test(settings.url);
    if (hasPlaceholder) { dataType = 'jsonp'; }

    if (settings.cache === false || (
         (!options || options.cache !== true) &&
         ('script' == dataType || 'jsonp' == dataType)
        ))
      { settings.url = appendQuery(settings.url, '_=' + Date.now()); }

    if ('jsonp' == dataType) {
      if (!hasPlaceholder)
        { settings.url = appendQuery(settings.url,
          settings.jsonp ? (settings.jsonp + '=?') : settings.jsonp === false ? '' : 'callback=?'); }
      return $.ajaxJSONP(settings, deferred)
    }

    var mime = settings.accepts[dataType],
        headers = { },
        setHeader = function(name, value) { headers[name.toLowerCase()] = [name, value]; },
        protocol = /^([\w-]+:)\/\//.test(settings.url) ? RegExp.$1 : window.location.protocol,
        xhr = settings.xhr(),
        nativeSetHeader = xhr.setRequestHeader,
        abortTimeout;

    if (deferred) { deferred.promise(xhr); }

    if (!settings.crossDomain) { setHeader('X-Requested-With', 'XMLHttpRequest'); }
    setHeader('Accept', mime || '*/*');
    if (mime = settings.mimeType || mime) {
      if (mime.indexOf(',') > -1) { mime = mime.split(',', 2)[0]; }
      xhr.overrideMimeType && xhr.overrideMimeType(mime);
    }
    if (settings.contentType || (settings.contentType !== false && settings.data && settings.type.toUpperCase() != 'GET'))
      { setHeader('Content-Type', settings.contentType || 'application/x-www-form-urlencoded'); }

    if (settings.headers) { for (name in settings.headers) { setHeader(name, settings.headers[name]); } }
    xhr.setRequestHeader = setHeader;

    xhr.onreadystatechange = function(){
      if (xhr.readyState == 4) {
        xhr.onreadystatechange = empty;
        clearTimeout(abortTimeout);
        var result, error = false;
        if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304 || (xhr.status == 0 && protocol == 'file:')) {
          dataType = dataType || mimeToDataType(settings.mimeType || xhr.getResponseHeader('content-type'));

          if (xhr.responseType == 'arraybuffer' || xhr.responseType == 'blob')
            { result = xhr.response; }
          else {
            result = xhr.responseText;

            try {
              // http://perfectionkills.com/global-eval-what-are-the-options/
              // sanitize response accordingly if data filter callback provided
              result = ajaxDataFilter(result, dataType, settings);
              if (dataType == 'script')    { (1,eval)(result); }
              else if (dataType == 'xml')  { result = xhr.responseXML; }
              else if (dataType == 'json') { result = blankRE.test(result) ? null : $.parseJSON(result); }
            } catch (e) { error = e; }

            if (error) { return ajaxError(error, 'parsererror', xhr, settings, deferred) }
          }

          ajaxSuccess(result, xhr, settings, deferred);
        } else {
          ajaxError(xhr.statusText || null, xhr.status ? 'error' : 'abort', xhr, settings, deferred);
        }
      }
    };

    if (ajaxBeforeSend(xhr, settings) === false) {
      xhr.abort();
      ajaxError(null, 'abort', xhr, settings, deferred);
      return xhr
    }

    var async = 'async' in settings ? settings.async : true;
    xhr.open(settings.type, settings.url, async, settings.username, settings.password);

    if (settings.xhrFields) { for (name in settings.xhrFields) { xhr[name] = settings.xhrFields[name]; } }

    for (name in headers) { nativeSetHeader.apply(xhr, headers[name]); }

    if (settings.timeout > 0) { abortTimeout = setTimeout(function(){
        xhr.onreadystatechange = empty;
        xhr.abort();
        ajaxError(null, 'timeout', xhr, settings, deferred);
      }, settings.timeout); }

    // avoid sending empty string (#319)
    xhr.send(settings.data ? settings.data : null);
    return xhr
  };

  // handle optional data/success arguments
  function parseArguments(url, data, success, dataType) {
    if ($.isFunction(data)) { dataType = success, success = data, data = undefined; }
    if (!$.isFunction(success)) { dataType = success, success = undefined; }
    return {
      url: url
    , data: data
    , success: success
    , dataType: dataType
    }
  }

  $.get = function(/* url, data, success, dataType */){
    return $.ajax(parseArguments.apply(null, arguments))
  };

  $.post = function(/* url, data, success, dataType */){
    var options = parseArguments.apply(null, arguments);
    options.type = 'POST';
    return $.ajax(options)
  };

  $.getJSON = function(/* url, data, success */){
    var options = parseArguments.apply(null, arguments);
    options.dataType = 'json';
    return $.ajax(options)
  };

  $.fn.load = function(url, data, success){
    if (!this.length) { return this }
    var self = this, parts = url.split(/\s/), selector,
        options = parseArguments(url, data, success),
        callback = options.success;
    if (parts.length > 1) { options.url = parts[0], selector = parts[1]; }
    options.success = function(response){
      self.html(selector ?
        $('<div>').html(response.replace(rscript, "")).find(selector)
        : response);
      callback && callback.apply(self, arguments);
    };
    $.ajax(options);
    return this
  };

  var escape = encodeURIComponent;

  function serialize(params, obj, traditional, scope){
    var type, array = $.isArray(obj), hash = $.isPlainObject(obj);
    $.each(obj, function(key, value) {
      type = $.type(value);
      if (scope) { key = traditional ? scope :
        scope + '[' + (hash || type == 'object' || type == 'array' ? key : '') + ']'; }
      // handle data in serializeArray() format
      if (!scope && array) { params.add(value.name, value.value); }
      // recurse into nested objects
      else if (type == "array" || (!traditional && type == "object"))
        { serialize(params, value, traditional, key); }
      else { params.add(key, value); }
    });
  }

  $.param = function(obj, traditional){
    var params = [];
    params.add = function(key, value) {
      if ($.isFunction(value)) { value = value(); }
      if (value == null) { value = ""; }
      this.push(escape(key) + '=' + escape(value));
    };
    serialize(params, obj, traditional);
    return params.join('&').replace(/%20/g, '+')
  };
})(Zepto)

//     Zepto.js
//     (c) 2010-2016 Thomas Fuchs
//     Zepto.js may be freely distributed under the MIT license.

;(function($){
  $.fn.serializeArray = function() {
    var name, type, result = [],
      add = function(value) {
        if (value.forEach) { return value.forEach(add) }
        result.push({ name: name, value: value });
      };
    if (this[0]) { $.each(this[0].elements, function(_, field){
      type = field.type, name = field.name;
      if (name && field.nodeName.toLowerCase() != 'fieldset' &&
        !field.disabled && type != 'submit' && type != 'reset' && type != 'button' && type != 'file' &&
        ((type != 'radio' && type != 'checkbox') || field.checked))
          { add($(field).val()); }
    }); }
    return result
  };

  $.fn.serialize = function(){
    var result = [];
    this.serializeArray().forEach(function(elm){
      result.push(encodeURIComponent(elm.name) + '=' + encodeURIComponent(elm.value));
    });
    return result.join('&')
  };

  $.fn.submit = function(callback) {
    if (0 in arguments) { this.bind('submit', callback); }
    else if (this.length) {
      var event = $.Event('submit');
      this.eq(0).trigger(event);
      if (!event.isDefaultPrevented()) { this.get(0).submit(); }
    }
    return this
  };

})(Zepto)

//     Zepto.js
//     (c) 2010-2016 Thomas Fuchs
//     Zepto.js may be freely distributed under the MIT license.

// The following code is heavily inspired by jQuery's $.fn.data()

;(function($){
  var data = {}, dataAttr = $.fn.data, camelize = $.camelCase,
    exp = $.expando = 'Zepto' + (+new Date()), emptyArray = [];

  // Get value from node:
  // 1. first try key as given,
  // 2. then try camelized key,
  // 3. fall back to reading "data-*" attribute.
  function getData(node, name) {
    var id = node[exp], store = id && data[id];
    if (name === undefined) { return store || setData(node) }
    else {
      if (store) {
        if (name in store) { return store[name] }
        var camelName = camelize(name);
        if (camelName in store) { return store[camelName] }
      }
      return dataAttr.call($(node), name)
    }
  }

  // Store value under camelized key on node
  function setData(node, name, value) {
    var id = node[exp] || (node[exp] = ++$.uuid),
      store = data[id] || (data[id] = attributeData(node));
    if (name !== undefined) { store[camelize(name)] = value; }
    return store
  }

  // Read all "data-*" attributes from a node
  function attributeData(node) {
    var store = {};
    $.each(node.attributes || emptyArray, function(i, attr){
      if (attr.name.indexOf('data-') == 0)
        { store[camelize(attr.name.replace('data-', ''))] =
          $.zepto.deserializeValue(attr.value); }
    });
    return store
  }

  $.fn.data = function(name, value) {
    return value === undefined ?
      // set multiple values via object
      $.isPlainObject(name) ?
        this.each(function(i, node){
          $.each(name, function(key, value){ setData(node, key, value); });
        }) :
        // get value from first element
        (0 in this ? getData(this[0], name) : undefined) :
      // set value on all elements
      this.each(function(){ setData(this, name, value); })
  };

  $.data = function(elem, name, value) {
    return $(elem).data(name, value)
  };

  $.hasData = function(elem) {
    var id = elem[exp], store = id && data[id];
    return store ? !$.isEmptyObject(store) : false
  };

  $.fn.removeData = function(names) {
    if (typeof names == 'string') { names = names.split(/\s+/); }
    return this.each(function(){
      var id = this[exp], store = id && data[id];
      if (store) { $.each(names || store, function(key){
        delete store[names ? camelize(this) : key];
      }); }
    })
  }

  // Generate extended `remove` and `empty` functions
  ;['remove', 'empty'].forEach(function(methodName){
    var origFn = $.fn[methodName];
    $.fn[methodName] = function() {
      var elements = this.find('*');
      if (methodName === 'remove') { elements = elements.add(this); }
      elements.removeData();
      return origFn.call(this)
    };
  });
})(Zepto)

//     Zepto.js
//     (c) 2010-2016 Thomas Fuchs
//     Zepto.js may be freely distributed under the MIT license.

;(function($){
  // Create a collection of callbacks to be fired in a sequence, with configurable behaviour
  // Option flags:
  //   - once: Callbacks fired at most one time.
  //   - memory: Remember the most recent context and arguments
  //   - stopOnFalse: Cease iterating over callback list
  //   - unique: Permit adding at most one instance of the same callback
  $.Callbacks = function(options) {
    options = $.extend({}, options);

    var memory, // Last fire value (for non-forgettable lists)
        fired,  // Flag to know if list was already fired
        firing, // Flag to know if list is currently firing
        firingStart, // First callback to fire (used internally by add and fireWith)
        firingLength, // End of the loop when firing
        firingIndex, // Index of currently firing callback (modified by remove if needed)
        list = [], // Actual callback list
        stack = !options.once && [], // Stack of fire calls for repeatable lists
        fire = function(data) {
          memory = options.memory && data;
          fired = true;
          firingIndex = firingStart || 0;
          firingStart = 0;
          firingLength = list.length;
          firing = true;
          for ( ; list && firingIndex < firingLength ; ++firingIndex ) {
            if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
              memory = false;
              break
            }
          }
          firing = false;
          if (list) {
            if (stack) { stack.length && fire(stack.shift()); }
            else if (memory) { list.length = 0; }
            else { Callbacks.disable(); }
          }
        },

        Callbacks = {
          add: function() {
            if (list) {
              var start = list.length,
                  add = function(args) {
                    $.each(args, function(_, arg){
                      if (typeof arg === "function") {
                        if (!options.unique || !Callbacks.has(arg)) { list.push(arg); }
                      }
                      else if (arg && arg.length && typeof arg !== 'string') { add(arg); }
                    });
                  };
              add(arguments);
              if (firing) { firingLength = list.length; }
              else if (memory) {
                firingStart = start;
                fire(memory);
              }
            }
            return this
          },
          remove: function() {
            if (list) {
              $.each(arguments, function(_, arg){
                var index;
                while ((index = $.inArray(arg, list, index)) > -1) {
                  list.splice(index, 1);
                  // Handle firing indexes
                  if (firing) {
                    if (index <= firingLength) { --firingLength; }
                    if (index <= firingIndex) { --firingIndex; }
                  }
                }
              });
            }
            return this
          },
          has: function(fn) {
            return !!(list && (fn ? $.inArray(fn, list) > -1 : list.length))
          },
          empty: function() {
            firingLength = list.length = 0;
            return this
          },
          disable: function() {
            list = stack = memory = undefined;
            return this
          },
          disabled: function() {
            return !list
          },
          lock: function() {
            stack = undefined;
            if (!memory) { Callbacks.disable(); }
            return this
          },
          locked: function() {
            return !stack
          },
          fireWith: function(context, args) {
            if (list && (!fired || stack)) {
              args = args || [];
              args = [context, args.slice ? args.slice() : args];
              if (firing) { stack.push(args); }
              else { fire(args); }
            }
            return this
          },
          fire: function() {
            return Callbacks.fireWith(this, arguments)
          },
          fired: function() {
            return !!fired
          }
        };

    return Callbacks
  };
})(Zepto)

//     Zepto.js
//     (c) 2010-2016 Thomas Fuchs
//     Zepto.js may be freely distributed under the MIT license.
//
//     Some code (c) 2005, 2013 jQuery Foundation, Inc. and other contributors

;(function($){
  var slice = Array.prototype.slice;

  function Deferred(func) {
    var tuples = [
          // action, add listener, listener list, final state
          [ "resolve", "done", $.Callbacks({once:1, memory:1}), "resolved" ],
          [ "reject", "fail", $.Callbacks({once:1, memory:1}), "rejected" ],
          [ "notify", "progress", $.Callbacks({memory:1}) ]
        ],
        state = "pending",
        promise = {
          state: function() {
            return state
          },
          always: function() {
            deferred.done(arguments).fail(arguments);
            return this
          },
          then: function(/* fnDone [, fnFailed [, fnProgress]] */) {
            var fns = arguments;
            return Deferred(function(defer){
              $.each(tuples, function(i, tuple){
                var fn = $.isFunction(fns[i]) && fns[i];
                deferred[tuple[1]](function(){
                  var returned = fn && fn.apply(this, arguments);
                  if (returned && $.isFunction(returned.promise)) {
                    returned.promise()
                      .done(defer.resolve)
                      .fail(defer.reject)
                      .progress(defer.notify);
                  } else {
                    var context = this === promise ? defer.promise() : this,
                        values = fn ? [returned] : arguments;
                    defer[tuple[0] + "With"](context, values);
                  }
                });
              });
              fns = null;
            }).promise()
          },

          promise: function(obj) {
            return obj != null ? $.extend( obj, promise ) : promise
          }
        },
        deferred = {};

    $.each(tuples, function(i, tuple){
      var list = tuple[2],
          stateString = tuple[3];

      promise[tuple[1]] = list.add;

      if (stateString) {
        list.add(function(){
          state = stateString;
        }, tuples[i^1][2].disable, tuples[2][2].lock);
      }

      deferred[tuple[0]] = function(){
        deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);
        return this
      };
      deferred[tuple[0] + "With"] = list.fireWith;
    });

    promise.promise(deferred);
    if (func) { func.call(deferred, deferred); }
    return deferred
  }

  $.when = function(sub) {
    var resolveValues = slice.call(arguments),
        len = resolveValues.length,
        i = 0,
        remain = len !== 1 || (sub && $.isFunction(sub.promise)) ? len : 0,
        deferred = remain === 1 ? sub : Deferred(),
        progressValues, progressContexts, resolveContexts,
        updateFn = function(i, ctx, val){
          return function(value){
            ctx[i] = this;
            val[i] = arguments.length > 1 ? slice.call(arguments) : value;
            if (val === progressValues) {
              deferred.notifyWith(ctx, val);
            } else if (!(--remain)) {
              deferred.resolveWith(ctx, val);
            }
          }
        };

    if (len > 1) {
      progressValues = new Array(len);
      progressContexts = new Array(len);
      resolveContexts = new Array(len);
      for ( ; i < len; ++i ) {
        if (resolveValues[i] && $.isFunction(resolveValues[i].promise)) {
          resolveValues[i].promise()
            .done(updateFn(i, resolveContexts, resolveValues))
            .fail(deferred.reject)
            .progress(updateFn(i, progressContexts, progressValues));
        } else {
          --remain;
        }
      }
    }
    if (!remain) { deferred.resolveWith(resolveContexts, resolveValues); }
    return deferred.promise()
  };

  $.Deferred = Deferred;
})(Zepto);

var _onObj = {};
var _oneObj = {};

var event = {
  /**
   * 监听事件
   * @param  {String}   key 事件名称
   * @param  {Function} fn  回调函数
   */
  on: function on(key, fn) {
    if(_onObj[key] === undefined) {
      _onObj[key] = [];
    }

    _onObj[key].push(fn);
  },

  one: function one(key, fn) {
    if(_oneObj[key] === undefined) {
      _oneObj[key] = [];
    }

    _oneObj[key].push(fn);
  },

  off: function off(key) {
    _onObj[key] = [];
    _oneObj[key] = [];
  },

  emit: function emit() {
    var this$1 = this;

    var key, args;
    if(!arguments.length) {
      return false
    }

    key = arguments[0];
    args = [].concat(Array.prototype.slice.call(arguments, 1));

    if(_onObj[key] && _onObj[key].length) {
      for(var i in _onObj[key]) {
        _onObj[key][i].apply(null, args);
      }
    }

    if(_oneObj[key] && _oneObj[key].length) {
      for(var i$1 in this$1.oneObj[key]) {
        _oneObj[key][i$1].apply(null, args);
        _oneObj[key][i$1] = void(0);
      }
      _oneObj[key] = [];
    }
  }
};

var eventPlus = {
  showEvents: function showEvents(type) {
    var events =  {
      on: Object.keys(_onObj),
      one: Object.keys(_oneObj)
    };

    return type ? events[type] : events
  }
};

var superEvent = $.extend(eventPlus, event);

var SID = 'mr-type';

var runtime = {
  // 模块实例集合
  // 在继承了 BaseModule 的组件对象实例化时注册
  // 在 ModuleFactory 自动绑定 DOM 组件时注册
  // {
  //   Foo: [  // 键值为 class name
  //     {
  //        el: Element,
  //        obj: foo,
  //        src: 'obj'
  //     },
  //     {
  //        el: Element,
  //        obj: foo,
  //        src: 'dom'
  //     },
  //     ...
  //   ],
  //   Bar: [{bar1}, {bar2}, ...]
  // }
  instancePool: {
    get length() {
      return Object.keys(runtime.instancePool).length - 1
    }
  },

  // 模块构造器数集合，由 BaseModule.regist 注册
  // {<typeName>: <Class>}
  // {
  //   foo: class Foo,
  //   bar: class Bar
  // }
  classPool: {}
};

var context = {
  // 支持原生对象，Zepto对象，CSS 选择器
  getInstance: function getInstance(selector) {
    var results = queryInstances(selector);

    switch (results.length) {
      case 0:
        return null
      case 1:
        return results[0]['obj']
      default:
        return results.map(function (mod) { return mod.obj; })
    }
  },

  /**
   * 获取所有通过 BaseModule.regist 注册的类
   * @return {Array} [{class: 'Foo', typeName: 'foo'}]
   */
  showProtoes: function showProtoes() {
    return Object.keys(runtime.classPool).map(function (name) {
      return {
        class: runtime.classPool[name].name,
        typeName: name
      }
    })
  },

  getProto: function getProto(typeName) {
    return runtime.classPool[typeName]
  },

  destroy: function destroy(obj) {}
};

/**
 * 将组件初始化后的实例对象注册到 runtime 的实例池中
 * @param  {Module Object} obj 组件对象
 * @param  {Element} el  组件绑定的原生 DOM 元素
 */
function registerRuntime(obj, el) {
  var className = obj.constructor.name;
  var conf = {
    obj: obj,
    el: el,
    className: className,
    index: getInitedObjIndex(className, el)
  };

  if (conf.index > -1) {
    console.warn(el);
    throw new Error('同一元素不可绑定多个对象')
  } else if (hasInstanceType(className)) {
    patchInstance(conf);
  } else {
    addInstance(conf);
  }
  // console.log(el)
}

function addInstance(ins) {
  Object.defineProperty(runtime.instancePool, ins.className, {
    value: [
      {
        obj: ins.obj,
        el: ins.el,
        src: ins.el['__src'] === 'dom' ? 'dom' : 'obj'
      }
    ],
    writable: false,
    enumerable: true
  });
}

function patchInstance(ins) {
  runtime.instancePool[ins.className].push({
    obj: ins.obj,
    el: ins.el,
    src: ins.el['__src'] === 'dom' ? 'dom' : 'obj'
  });
}

// function replaceInstance(ins) {
//   const instanceList = getInstancesByClassName(ins.className)

//   if (ins.el['__src'] !== 'dom') {
//     instanceList[ins.index].obj = ins.obj
//   }
// }

function hasInstanceType(className) {
  return runtime.instancePool.hasOwnProperty(className)
}

// 根据查找某类别下绑定的实例，未找到索引时，返回 -1
function getInitedObjIndex(className, el) {
  if (!hasInstanceType(className)) { return -1 }

  var instanceList = getInstancesByClassName(className);

  for (var i = 0; i < instanceList.length; i++) {
    if (instanceList[i].el.isEqualNode(el)) { return i }
  }

  return -1
}

// 当为 dom list 时取第一个元素，包装为 Zepto 对象
// el 非法时，返回 undefined
function getEl(el) {
  var p = function ($el) { return ($el.length > 0 ? (($el['__ck'] = true), $el) : void 0); };

  switch (true) {
    case el instanceof Element:
      return p($(el))
    case el instanceof NodeList:
      return p($(el[0]))
    case el instanceof HTMLCollection:
      return p($(el[0]))
    case el && el['__ck']:
      return el // $el
    default:
      return p($($(el).get(0))) // Zepto
  }
}

// el 参数类型安全，兼容原生 Element 与 Zepto 对象
function getTypeNameByDOM($el) {
  return $el ? $el.attr(SID) : $el
}

function getClassNameByDOM($el) {
  var typeName = getTypeNameByDOM($el);
  var MClass = context.getProto(typeName);
  return MClass && MClass.name
}

function getInstancesByClassName(name) {
  var objs = runtime.instancePool[name];

  // 始终返回数组，方便遍历使用
  return typeof objs === 'undefined' ? [] : objs
}

function getInstancesByDOM($el) {
  var className = getClassNameByDOM($el);
  return getInstancesByClassName(className)
}

function queryInstances(selector) {
  var $el = getEl(selector);
  var instanceList = getInstancesByDOM($el);

  return instanceList.filter(function (mod) { return mod.el.isEqualNode($el[0]); })
}

function destroyRuntime(obj) {
  console.log('destroy', obj);
}

var BaseModule = function BaseModule(el, options, isRoot) {
  if ( options === void 0 ) options = {};
  if ( isRoot === void 0 ) isRoot = false;

  var $el = this.$el = getEl(el);

  // 模块实例 on 事件集合
  var _evtOn = {};

  // 模块实例 one 事件集合
  var _evtOne = {};

  if(!$el) { throw new Error('can\'t find element') }

  var config = this._getDOMConfig(el);

  this.__options = isRoot ? Zepto.extend(true, config, options) : Zepto.extend(true, options, config);

  this.on = function(key, fn) {
    if(_evtOn[key] === undefined) {
      _evtOn[key] = [];
    }

    _evtOn[key].push(fn);
  };

  this.one = function(key, fn) {
    if(_evtOne[key] === undefined) {
      _evtOne[key] = [];
    }

    _evtOne[key].push(fn);
  };

  this.off = function(key) {
    _evtOn[key] = [];
    _evtOne[key] = [];
  };

  /**
   * 触发事件
   * @param{String}事件名
   * @param{...args}不定参数，事件信息
   */
  this.emit = function() {
    var this$1 = this;

    var key, args;
    if(!arguments.length) {
      return false
    }

    key = arguments[0];
    args = [].concat(Array.prototype.slice.call(arguments, 1));

    if(_evtOn[key] && _evtOn[key].length) {
      for(var i in _evtOn[key]) {
        _evtOn[key][i].apply(null, args);
      }
    }

    if(_evtOne[key] && _evtOne[key].length) {
      for(var i$1 in this$1.oneObj[key]) {
        _evtOne[key][i$1].apply(null, args);
        _evtOne[key][i$1] = void(0);
      }
      _evtOne[key] = [];
    }
  };

  $el.attr(SID, this.constructor.mrType);
  registerRuntime(this, $el[0]);
};

BaseModule.register = function register (ClassObj, typeName) {
  ClassObj.mrType = typeName;
  runtime.classPool[typeName] = ClassObj;
};

BaseModule.prototype.getContext = function getContext () {
  return context
};

BaseModule.prototype.getOptions = function getOptions (defConfig) {
    if ( defConfig === void 0 ) defConfig = {};

  return Zepto.extend(true, {}, defConfig, this.__options)
};

BaseModule.prototype.destroy = function destroy () {
  destroyRuntime(this);
};

BaseModule.prototype._getDOMConfig = function _getDOMConfig (el) {
  var $el = getEl(el || this.$el);

  // el 非法时，返回 {}
  if(typeof($el) === undefined) { return {} }

  var dataset = $el[0].dataset;
  var objDataset = getObjectAttr($el, 'datas-');

  // console.log(objDataset)

  return Zepto.extend({}, dataset, objDataset)
};

function getObjectAttr($el, flag) {
  if ( flag === void 0 ) flag = 'datas-';

  var attr = $el[0].attributes;
  var mDataset = {};

  for(var i = 0; i < attr.length; i++) {
    var name = attr[i].name;
    var val = attr[i].value;

    if(name.indexOf(flag) > -1) {
      name = name.replace(flag, '');
      mDataset[name] = parseJson(val);
    }
  }

  return mDataset
}

function parseJson(str) {
  try {
    return JSON.parse(str)
    // return eval('Object(' + str + ')')
  } catch(e) {
    return null
  }
}

var moduleFactory = {
  init: function init() {
    var this$1 = this;

    // const $mDOMs = $(`[${sid}auto]`).not(`[${sid}auto=false]`)
    var $mDOMs = Zepto(("[" + SID + "]")).not('[mr-auto=false]');

    $mDOMs.each(function (i, el) {
      // 查询 context 实例池，避免用户在 ready 事件前
      // 调用 new 构造实例后，框架扫描 DOM 自动初始化多次
      if(!context.getInstance(el)) {
        this$1.createModule(el);
      }
    });

    return context
  },

  createModule: function createModule(el) {
    var tName = Zepto(el).attr(SID);
    var Module = context.getProto(tName);
    var modObj = null;

    if(typeof(Module) === 'undefined') {
      console.warn(("Module [" + tName + "] is not regiested."));
      return null
    }

    el['__src'] = 'dom';
    modObj = new Module(el);
    delete el['__src'];

    return modObj
  }
};

var lifeCircle = {
  init: function init(cb) {
    console.log('init');
  },

  ready: function ready(cb) {
    $(function () {
      // 扫描绑定组件对象与 DOM 元素
      var context = moduleFactory.init();

      typeof(cb) === 'function' && cb(context);
    });
  },

  destroy: function destroy() {
    console.log('destroy');
  }
};

/**
 * 返回指定精度整型随机数
 * @param  {Number} min 左边距
 * @param  {Number} max 右边距
 * @return {Number}   指定范围随机数
 * random(1, 3)  // 1 | 2 | 3
 */
function random(min, max) {
  if ( min === void 0 ) min = 0;
  if ( max === void 0 ) max = 1;

  return Math.floor(Math.random() * (max - min + 1) + min)
}

/**
 * 原生选择器
 * @return {Element} 匹配元素列表
 * e.g.
 * q('.name')  // Element
 * q('.name', '.profile')  // Element
 */
function q() {
  return document.querySelectorAll.apply(document, arguments)
}

/**
 * 获取url参数
 * @param  {String} name 参数名
 * @return {String}      参数值
 * e.g.
 * // http://www.vv314.com?type=1&id=1
 * getUrlParam('id')  // 1
 * getUrlParam('name')  // null
 */
function getUrlParam(name) {
  var reg = new RegExp('(^|&)' + name + '=([^&]*)(&|$)');
  var value = window.location.search.substr(1).match(reg);

  return value === null ? null : decodeURI(value[2])
}

/**
 * 判断是否为微信浏览器
 * @return {Boolean}
 */
function isWechat() {
  var ua = navigator.userAgent.toLowerCase();
  return ua.match(/MicroMessenger/i) === 'micromessenger'
}

/**
 * 字符串超出截取，以省略号结尾
 * @param  {String} str    待截取字符串
 * @param  {Number} maxlength 长度
 * @return {String}        截取结果
 * e.g.
 * limitStr('abcdefg', 4) // abcd...
 */
function limitStr(str, maxlength) {
  return str.length > maxlength ? str.substr(0, maxlength) + '...' : str
}

/**
 * 设置/获取 localStorage
 * 当 value 缺省时为获取数据, value 为对象时,执行序列化
 * @param  {String} name  数据名
 * @param  {String} [value] 数据项
 * e.g.
 * storage('goodid')  // 获取 goodid
 * storage('profile', {name: fish, gender: 1})  // 存储 profile
 */
function storage(name, value) {
  var data = '';

  if (arguments.length === 1) {
    data = localStorage.getItem(name);
    try {
      return JSON.parse(data)
    } catch (e) {
      return data
    }
  } else {
    localStorage.setItem(
      name,
      typeof value === 'object' ? JSON.stringify(value) : value
    );
  }
}

/**
 * 判断字符串、数组、对象内容是否为空
 * @param  {String | Obejct}  obj  数据源
 * @return {Boolean}  判断结果
 * e.g.
 * isEmpty('')  // true
 * isEmpty([])  // true
 * isEmpty({})  // true
 * isEmpty({name: 'fish'})  // false
 */
function isEmpty(obj) {
  switch (typeof obj) {
    case 'undefined':
      return true
    case 'string':
      return !obj.length
    case 'object':
      return obj === null || !Object.keys(obj).length
  }
}

/**
 * 判断是否为数字或数字字符串
 * @param  {Number | String} 数据
 * @return {Boolean}       判断结果
 * e.g.
 * likeNumber(5)  // true
 * likeNumber('8')  // true
 * likeNumber('2a')  // false
 */
function likeNumber(value) {
  return !isNaN(Number(value))
}

/**
 * 邮箱格式验证
 * @param  {String} email  email地址
 * @return {Boolean}  验证结果
 * e.g.
 * vaildEmail('vv314@foxmail.com')  // true
 */
function testEmail(email) {
  var emailRegex = /^([\w-]+(?:\.[\w-]+)*)@((?:[\w-]+\.)*\w[\w-]{0,66})\.([a-z]{2,6}(?:\.[a-z]{2})?)$/i;

  return emailRegex.test(email)
}

/**
 * 检查 cookie 是否可用
 * @return {Boolean} true: 支持  false: 不支持
 */
function checkCookie() {
  // 现代浏览器已支持 cookieEnabled
  return !!window.navigator.cookieEnabled
}

/**
 * 获取 Cookie
 * @param  {String} name  cookie名称
 * @return {String}
 * e.g.
 * // cookie: name=fish
 * getCookie('name')  // fish
 * getCookie('age')  // ''
 */
function getCookie(name) {
  var reg = new RegExp(name + '=(.*?)($|;)');
  var value = reg.exec(document.cookie);

  return value === null ? '' : decodeURI(value[1])
}

/**
 * 设置 Cookie
 * @param {String} name   cookie 名
 * @param {String} value  cookie 值
 * @param {Number} days   有效时间
 * @param {String} domain 域名
 */
function setCookie(name, value, days, domain) {
  if ( days === void 0 ) days = 15;

  var exp = new Date();
  var domainStr = domain ? ("domain=" + domain) : '';

  exp.setDate(exp.getDate() + days);
  // 调用 encodeURI 对中文及特殊符号编码
  document.cookie = name + "=" + (encodeURI(
    value
  )) + ";expires=" + exp + ";path=/;" + domainStr;
}

/**
 * 删除 Cookie
 * @param {String} name  cookie 名称
 * @param {String} domain  域名
 */
function delCookie(name, domain) {
  setCookie(name, '', -1, domain);
}

/**
 * 格式化时间
 * @param  {Date} dateObj Date 对象或时间戳
 * @return {Object}
 */
function parseDate(dateObj) {
  var f = function (n) { return (n > 9 ? n : '0' + n); };
  var date = dateObj instanceof Date ? dateObj : new Date(dateObj);
  return {
    y: date.getFullYear(),
    M: f(date.getMonth() + 1),
    d: f(date.getDate()),
    h: f(date.getHours()),
    m: f(date.getMinutes()),
    s: f(date.getSeconds())
  }
}

/**
 * 节流函数
 * @param  {Function} method 函数
 * @param  {Number} delay   间隔时间
 * @return {Function}        新函数
 */
function throttle(method, delay) {
  var timer = null;

  return function() {
    var this$1 = this;

    var args = arguments;
    clearTimeout(timer);

    timer = setTimeout(function () {
      method.apply(this$1, args);
    }, delay);
  }
}

/**
 * 显示时钟
 * @param  {Function} cb         回调函数
 * @param  {Number}   freshTime 刷新时间，毫秒
 * @return {Object}             由 parseDate 返回的时间对象
 */
function realTime(cb, freshTime) {
  cb(parseDate(new Date()));

  return setInterval(function () {
    cb(parseDate(new Date()));
  }, freshTime || 1000)
}

/**
 * 格式化评论数
 * @param  {Number} num [description]
 * @return {String}     [description]
 *
 * e.g
 * reformNum(10000)  // 1万
 */
function reformNum(num) {
  if ( num === void 0 ) num = 0;

  var result = num;

  if (!num) { return 0 }

  if (num >= 1000000) {
    result = Math.floor(num / 10000) + '万';
  } else if (num >= 10000) {
    result = Number((num / 10000).toFixed(1)) + '万';
  }

  return result
}

function LoadProto() {
  function load(src, callback) {
    load.js(src, callback);
  }

  load.js = function (src, callback) {
    var id = getIdBySrc(src);
    var el = document.getElementById(id);

    if (el) {
      callback();
    } else {
      el = document.createElement('script');
      el.id = id;
      el.src = src;

      el.addEventListener('load', function(event) {
        callback(null, event);
      });

      el.addEventListener('error', callback);

      document.body.appendChild(el);
    }

    return el
  };

  load.series = function (urls, callback) {
    var url = urls.shift();

    if (url) {
      load(url, function (error) {
        error ? callback(error) : load.series(urls, callback);
      });
    } else {
      callback();
    }
  };

  load.parallel = function (urls, callback) {
    var i = urls.length;
    var done;
    var func = function (error) {
      --i;
      if ((!i && !done) || error) {
        done = true;
        callback(error);
      }
    };

    urls.forEach(function (url) { return load(url, func); });
  };

  function getIdBySrc(src) {
    var isStr = typeof src === 'string';
    var num, sub;

    if (!isStr) { return }

    if (~src.indexOf(':')) {
      src += '-join';
    }

    num = src.lastIndexOf('/') + 1;
    sub = src.substr(src, num);
    return src.replace(sub, '').replace(/\./g, '-')
  }

  return load
}

// 加载单个脚本
// load('https://sina.cn/a.js', callback)
//
// 串行加载脚本
// load.series(['https://sina.cn/a.js', 'https://sina.cn/b.js'], callback)
//
// 并行加载脚本
// load.parallel(['https://sina.cn/a.js', 'https://sina.cn/b.js'], callback)
var load = new LoadProto();

/**
 * 检测手势方向
 *
 * e.g
 * var touch = new Touch()
 *
 * touch.listen('#app', function(direction) {
 *   console.log(direction)
 * })
 */
var Touch = function Touch(threshold) {
  if ( threshold === void 0 ) threshold = 20;

  this.isMobile = 'ontouchstart' in window;
  this.threshold = threshold;
};

Touch.prototype._getAngle = function _getAngle (x, y) {
  return Math.atan2(y, x) * 180 / Math.PI
};

Touch.prototype.start = function start (e) {
  this.startX = this.isMobile ? e.touches[0].pageX : e.x;
  this.startY = this.isMobile ? e.touches[0].pageY : e.y;
};

Touch.prototype.end = function end (e) {
  this.endX = this.isMobile ? e.changedTouches[0].pageX : e.x;
  this.endY = this.isMobile ? e.changedTouches[0].pageY : e.y;

  return this._getDirection()
};

Touch.prototype._getDirection = function _getDirection () {
  var angX = this.endX - this.startX;
  var angY = this.endY - this.startY;
  var result = 'none';

  // 如果滑动距离太短
  if (Math.abs(angX) < this.threshold && Math.abs(angY) < this.threshold)
    { return result }

  var angle = this._getAngle(angX, angY);

  if (angle >= -135 && angle <= -45) {
    result = 'up';
  } else if (angle > 45 && angle < 135) {
    result = 'down';
  } else if (
    (angle >= 135 && angle <= 180) ||
    (angle >= -180 && angle < -135)
  ) {
    result = 'left';
  } else if (angle >= -45 && angle <= 45) {
    result = 'right';
  }

  return result
};

Touch.prototype.listen = function listen (selector, handle) {
    var this$1 = this;

  var touchEventsDesktop = { start: 'mousedown', end: 'mouseup' };

  if (window.navigator.pointerEnabled) {
    touchEventsDesktop = { start: 'pointerdown', end: 'pointerup' };
  } else if (window.navigator.msPointerEnabled) {
    touchEventsDesktop = { start: 'MSPointerDown', end: 'MSPointerUp' };
  }

  var touchEvent = {
    start: this.isMobile ? 'touchstart' : touchEventsDesktop.start,
    end: this.isMobile ? 'touchend' : touchEventsDesktop.end
  };

  $(selector).on(touchEvent.start, this.start.bind(this));
  $(selector).on(touchEvent.end, function (e) { return handle(this$1.end(e)); });
};




var utils = Object.freeze({
	q: q,
	load: load,
	random: random,
	getUrlParam: getUrlParam,
	isWechat: isWechat,
	limitStr: limitStr,
	storage: storage,
	isEmpty: isEmpty,
	testEmail: testEmail,
	likeNumber: likeNumber,
	checkCookie: checkCookie,
	getCookie: getCookie,
	setCookie: setCookie,
	delCookie: delCookie,
	parseDate: parseDate,
	throttle: throttle,
	realTime: realTime,
	reformNum: reformNum,
	Touch: Touch
});

var erudaUrl = '//mjs.sinaimg.cn/wap/online/others/eruda/eruda.min.js';
var mdebugUrl =
  '//mjs.sinaimg.cn/wap/online/public/mdebug/201706161130/js/index.min.js';

var fireMap = {
  _devtools: devtools,
  _mlog: mlog
};

function devtools(debugMode) {
  if (debugMode) {
    load(erudaUrl, function () {
      window.eruda && window.eruda.init();
      console.log('[base-utils] eruda ready');
    });
  }
}

function mlog(debugMode) {
  if (debugMode) {
    load(mdebugUrl, function () {
      console.log('[base-utils] mlog ready');
    });
  }
}

function init$1() {
  Object.keys(fireMap).forEach(function (key) { return fireMap[key](getUrlParam(key)); });
}

var Extra = {
  load: init$1,
  devtools: devtools,
  mlog: mlog
};

function init() {
  // 挂载全局命名空间，暴露 Circle.ready 函数与事件模块，
  // SINA_NEWS.event 模块阉割 showEvents 方法
  window.SINA_NEWS = window.SINA_NEWS || { ready: lifeCircle.ready, event: event };

  Extra.load();
}

init();

export { Zepto as $, BaseModule, utils as Utils, Zepto, lifeCircle as Page, superEvent as Event };export default Zepto;
